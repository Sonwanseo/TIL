# Chapter 10. 제너레이터

비동기 흐름 제어를 순차적/동기적 모습으로 나타내는 장치

## 10.1 완전-실행을 타파하다

완전-실행: 일단 함수가 실행되기 시작하면 완료될 때까지 계속 실행되며 도중에 다른 코드가 끼어들어 실행되지 않는 법칙

But, ES6부터는 완전-실행 법칙을 따르지 않는, 제너레이터라는 새로운 종류의 함수가 등장

선점형 멀티스레드 언어라면 일반적으로 두 문 사이의 특정 시점에 다른 함수가 끼어들어 실행되게 할 수 있지만 자바스크립트는 선점형 언어도, 멀티스레드 언어도 아님  
하지만 함수 자체가 어떤 코드 부분에서 멈춤 신호를 준다면 이러한 끼어들기가 가능

```javascript
var x = 1;

function* foo() {
  x++;
  yield; // 멈추시오!
  console.log("x:", x);
}

function bar() {
  x++;
}
```

**_제너레이터 함수를 보면 2가지 종류가 있다. function_ foo()와 function _foo(). 이는 그저 코딩 스타일의 차이일 뿐이다._**

```javascript
// 이터레이터 'it'를 선언하여 제너레이터를 제어한다.
var it = foo();

// 'foo()'는 여기서 시작된다!
it.next();
x; // 2
bar();
x; // 3
it.next(); // x: 3
```

1. var it = foo(); 할당으로 \*foo() 제너레이터가 실행되는 것은 아님  
   제너레이터 실행을 제어할 이터레이터만 마련
2. 이터레이터.next()로 다음 실행을 제어  
   yield; 부분에서 멈춤
3. 제너레이터가 진행을 멈춘 동안 bar()를 실행
4. 이터레이터.next()로 다음 실행을 제어

제너레이터는 1회 이상 시작/실행을 거듭할 수 있으면서도 반드시 끝까지 실행해야 할 필요는 없는 특별한 함수

### 10.1.1 입력과 출력

제너레이터도 함수이기 때문에 기본적인 체계, 즉 인자를 받고 어떤 값을 반환하는 기능은 일반 함수와 같음

하지만 여타 함수와 제너레이터의 호출 방법은 다름  
이전 코드에서 볼 수 있듯이 제너레이터는 var it = foo();를 선언하는 것만으로는 실행되지 않음  
이터레이터.next();를 해야 다음 yield 또는 제너레티어 끝까지 실행할 수 있음

next()의 결괏값은 \*foo()가 반환한 값을 value 프로퍼티에 저장한 객체

##### 반복 메시징

인자를 받아 결괏값을 내는 기능 외에도 제너레이터에는 yield와 next()를 통해 입력/출력 메시지를 주고받는 기능이 탑재되어 있음

```javascript
function* foo(x) {
  var y = x * (yield);
  return y;
}

var it = foo(6);

// 'foo()'를 시작한다.
it.next();

var res = it.next(7);

res.value; // 42
```

1. 인자 x 자리에 6을 넘기고 it.next()를 호출하여 *foo()를 시작  
   *foo()에서 var y = x ... 문이 처리될 즈음 yield에서 멈춤
2. 인자 x 자리에 7을 넘기고 it.next()를 호출하여 \*foo()에 yield 이하의 코드가 실행되게 함
3. var y = 6 \* 7;이 되고 반환값으로 value 프로퍼티에 return y;를 한 객체가 반환됨

##### 두 가지 질문

위 코드를 보고 yield는 한 개지만, next()가 두 개이므로 짝이 안맞는다고 생각할 수도 있음  
하지만 첫 번째 next()는 yield 전까지의 흐름을 제어하고, 두 번째 next()는 yield가 속해 있는 괄호부터 \*foo()의 return 문까지를 제어하기 때문에 짝이 맞음

제너레티어 함수는 양방향 메시징이 가능함  
표현식 yield...는 next() 호출에 대응하여 메시지를 보낼 수 있고 next()는 멈춘 yield표현식으로 값 전송이 가능

제너레이터 끝에 return 문이 따로 없으면 return 문이 있다고 치고 암시적으로 처리

이러한 질의 응답 체계는 매우 강력함

### 10.1.2 다중 이터레이터

구문 사용법만 놓고 보면 이터레이터로 제너레이터를 제어하는 건 선언된 제너레티어 함수 자체를 제어하는 것처럼 보임  
이터레이터를 생성할 때마다 해당 이터레이터가 제어할 제너레이터의 인스턴스 역시 암시적으로 생성됨

같은 제너레이터의 인스턴스를 동시에 여러 개 실행할 수 있고 인스턴스끼리 상호 작용도 가능

```javascript
function* foo() {
  var x = yield 2;
  z++;
  var y = yield x * z;
  console.log(x, y, z);
}

var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2 <-- yield 2
var val2 = it2.next().value; // 2 <-- yield 2

val1 = it1.next(val2 * 10).value; // 40 <-- x: 20, z: 2
val2 = it2.next(val1 * 5).value; // 600 <-- x: 200, z: 3

it1.next(val2 / 2); // y: 300
// 20 300 3
it2.next(val1 / 4); // y: 10
// 200 10 3
```

**_똑같은 제너레이터의 여러 인스턴스를 동시에 실행하는 가장 일반적인 상황은 독립적으로 연결된 자원으로부터 입력값 없이 제너레이터 스스로 값을 생산할 때다. 인스턴스 간 상호 작용이 주가 아니다._**

1. \*foo() 인스턴스 2개를 동시에 실행하고 두 next() 호출 모두 yield 2 지점에서 2 값을 각각 넘겨받음
2. val2 \* 10은 2 \* 10이고 이 값은 첫 번째 인스턴스 it1에 전달되어 x 값은 20이 됨  
   z 값은 1에서 2로 증가하고 20 \* 2를 yield하므로 val1은 40이 됨
3. val1 \* 5는 40 \* 5이고 이 값은 두 번째 인스턴스 it2에 전달되어 x 값은 200이 됨  
   z 값은 다시 2에서 3으로 증가하고 200 \* 3을 yield하면 val2는 600이 됨
4. val2 / 2는 600 / 2이고 it1로 전달되어 y 값은 300이 되고 콘솔창엔 x y z 값이 20 300 3으로 각각 표시됨
5. val1 / 4는 40 / 4이고 it2로 전달되어 y 값은 10이 되고 콘솔창엔 200 10 3이 표시됨

##### 인터리빙

```javascript
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}
```

일반 자바스크립트 함수 foo(), bar() 둘 중 하나는 다른 함수보다 먼저 완전-실행될 것임  
하지만 foo()의 개별 문을 bar()에 인터리빙하여 실행하는 것은 불가능

반면 제너레이터는 문 사이에서도 인터리빙이 가능

같은 변수를 공유한 상태에서 두 제너레이터의 이터레이터를 인터리빙 함으로써 이론적 스레드 경합 조건이 발생하는 환경을 재현할 수 있음

## 10.2 값을 제너레이팅

### 10.2.1 제조기와 이터레이터

이터레이터는 생산자로부터 일련의 값들을 받아 하나씩 거치기 위한, 명확한 인터페이스  
대다수의 다른 언어처럼 자바스크립트에서도 이터레이터 인터페이스는 생산기에서 다음 값이 필요할 때마다 next()를 호출함

```javascript
var something = function () {
  var nextVal;

  return {
    // 'for...of' 루프에서 필요하다.
    [Symbol.iterator]: function () {
      return this;
    },

    // 표준 이터레이터 인터페이스 메서드
    next: function () {
      if (nextVal === undefined) {
        nextVal = 1;
      } else {
        nextVal = 3 * nextVal + 6;
      }

      return {
        done: false,
        value: nextVal,
      };
    },
  };
};
```

next()를 호출하면 프로퍼티가 2개인 객체가 반환됨  
done은 이터레이터 완료 상태를 기리키는 불리언 값이고 value는 순회값

ES6는 for...of 루프를 지원하여 표준 이터레이터를 자동으로 기존 루프 형태로 쓸 수 있음

```javascript
for (var v of something) {
  console.log(v);

  // 무한 루프가 되지 않게 하라!
  if (v > 500) {
    break;
  }
}
// 1 9 33 105 321 969
```

for...of 루프는 매번 자동으로 next()를 호출하다가 done: true를 받으면 그 자리에서 멈춤

이터레이터를 직접 수동 순회하는 것도 가능함

손수 이터레이터를 제작해도 상관없지만 ES6부터 배열 같은 자바스크립트 내장 자료 구조 대부분에는 기본 이터레이터가 장착되어 있음

**_일반 객체엔 배열처럼 기본 이터레이터가 없다._**
