# Chapter 10. 제너레이터

비동기 흐름 제어를 순차적/동기적 모습으로 나타내는 장치

## 10.1 완전-실행을 타파하다

완전-실행: 일단 함수가 실행되기 시작하면 완료될 때까지 계속 실행되며 도중에 다른 코드가 끼어들어 실행되지 않는 법칙

But, ES6부터는 완전-실행 법칙을 따르지 않는, 제너레이터라는 새로운 종류의 함수가 등장

선점형 멀티스레드 언어라면 일반적으로 두 문 사이의 특정 시점에 다른 함수가 끼어들어 실행되게 할 수 있지만 자바스크립트는 선점형 언어도, 멀티스레드 언어도 아님  
하지만 함수 자체가 어떤 코드 부분에서 멈춤 신호를 준다면 이러한 끼어들기가 가능

```javascript
var x = 1;

function* foo() {
  x++;
  yield; // 멈추시오!
  console.log("x:", x);
}

function bar() {
  x++;
}
```

**_제너레이터 함수를 보면 2가지 종류가 있다. function_ foo()와 function _foo(). 이는 그저 코딩 스타일의 차이일 뿐이다._**

```javascript
// 이터레이터 'it'를 선언하여 제너레이터를 제어한다.
var it = foo();

// 'foo()'는 여기서 시작된다!
it.next();
x; // 2
bar();
x; // 3
it.next(); // x: 3
```

1. var it = foo(); 할당으로 \*foo() 제너레이터가 실행되는 것은 아님  
   제너레이터 실행을 제어할 이터레이터만 마련
2. 이터레이터.next()로 다음 실행을 제어  
   yield; 부분에서 멈춤
3. 제너레이터가 진행을 멈춘 동안 bar()를 실행
4. 이터레이터.next()로 다음 실행을 제어

제너레이터는 1회 이상 시작/실행을 거듭할 수 있으면서도 반드시 끝까지 실행해야 할 필요는 없는 특별한 함수

### 10.1.1 입력과 출력

제너레이터도 함수이기 때문에 기본적인 체계, 즉 인자를 받고 어떤 값을 반환하는 기능은 일반 함수와 같음

하지만 여타 함수와 제너레이터의 호출 방법은 다름  
이전 코드에서 볼 수 있듯이 제너레이터는 var it = foo();를 선언하는 것만으로는 실행되지 않음  
이터레이터.next();를 해야 다음 yield 또는 제너레티어 끝까지 실행할 수 있음

next()의 결괏값은 \*foo()가 반환한 값을 value 프로퍼티에 저장한 객체

##### 반복 메시징

인자를 받아 결괏값을 내는 기능 외에도 제너레이터에는 yield와 next()를 통해 입력/출력 메시지를 주고받는 기능이 탑재되어 있음

```javascript
function* foo(x) {
  var y = x * (yield);
  return y;
}

var it = foo(6);

// 'foo()'를 시작한다.
it.next();

var res = it.next(7);

res.value; // 42
```

1. 인자 x 자리에 6을 넘기고 it.next()를 호출하여 *foo()를 시작  
   *foo()에서 var y = x ... 문이 처리될 즈음 yield에서 멈춤
2. 인자 x 자리에 7을 넘기고 it.next()를 호출하여 \*foo()에 yield 이하의 코드가 실행되게 함
3. var y = 6 \* 7;이 되고 반환값으로 value 프로퍼티에 return y;를 한 객체가 반환됨

##### 두 가지 질문

위 코드를 보고 yield는 한 개지만, next()가 두 개이므로 짝이 안맞는다고 생각할 수도 있음  
하지만 첫 번째 next()는 yield 전까지의 흐름을 제어하고, 두 번째 next()는 yield가 속해 있는 괄호부터 \*foo()의 return 문까지를 제어하기 때문에 짝이 맞음

제너레티어 함수는 양방향 메시징이 가능함  
표현식 yield...는 next() 호출에 대응하여 메시지를 보낼 수 있고 next()는 멈춘 yield표현식으로 값 전송이 가능

제너레이터 끝에 return 문이 따로 없으면 return 문이 있다고 치고 암시적으로 처리

이러한 질의 응답 체계는 매우 강력함
