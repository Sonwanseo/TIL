# Chapter 11. 프로그램 성능

자바스크립트에서 비동기성이 중요한 이유는 바로 성능 때문

2개의 독립적인 AJAX 요청이 다 끝나야만 다음 단계로 진행하는 코드가 있을 때, 이 둘의 상호 작용은 '순차', '동시' 두 가지 방법으로 모델링 가능

즉, 첫 번째 요청을 하고 완료되면 두 번째 요청을 시작하거나, 프라미스/제너레이터처럼 두 요청을 병렬 전송한 뒤 둘 다 관문을 통과할 때까지 잠시 대기한 후 진행하는 두 가지

당연히 후자가 전자에 비해 성능이 훨씬 우수함

프로그램 전체 실행 시간이 같더라도 비동기성은 체감 성능을 높여줌

## 11.1 웹 워커

자바스크립트는 단일-스레드로만 실행됨  
하지만 단일-스레드가 프로그램 실행을 구조화할 수 있는 유일한 방법은 아님

브라우저 같은 환경은 다수의 자바스크립트 엔진 인스턴스를 쉽게 내어줄 수 있고 인스턴스마다 개별 스레드를 배정하여 실행할 수도 있음  
이러한 프로그램의 독립적인 스레드 조각을 워커라고 하는데 프로그램을 덩이로 나누어 병렬 실행하는 '작업 병행성'을 추구

자바스크립트 메인 프로그램에서 워커는 다음과 같이 인스턴스화함

```javascript
var w1 = new Worker("http://some.url.1/mycoolworker.js");
```

워커로 읽어들일 자바스킓트 파일의 URL을 지정하면 브라우저는 이 파일을 별도의 스레드에서 독립적인 프로그램으로 실행

**_이렇게 URL로 생성한 워커를 전용 워커라 부른다. 하나의 값에 저장한 인라인 파일이므로 외부 파일 URL 대신 Blob URL로 인라인 워커를 생성하는 방법도 있다._**

워커는 같은 워커끼리, 심지어는 메인 프로그램과도 스코프 및 자원을 공유하지 않지만 기본적인 이벤트 메시징 체계를 바탕으로 서로 연결함

워커 객체 w1은 이벤트 리스너 + 트리거로, 워커가 보낸 이벤트를 구독하고 워커에 이벤트를 보냄

전용 워커는 자신을 만든 프로그램과 1:1 관계  
따라서 메시지 이벤트는 오직 이 1:1 관계에서 비롯됐으니 굳이 구별할 이유가 없음

대개 워커는 메인 페이지 애플리케이션에서 만들지만 필요하면 자신의 자식 워커를 인스턴스화할 수 있음  
세부 로직은 마스터 워커에게 넘겨서 작업 전체를 단계별로 처리할 다른 워커들을 생성하도록 위임하는 편이 유용

워커를 낳은 프로그램은 워커 객체를 terminate()해서 곧바로 제거

브라우저에서 다수의 페이지가 같은 파일 URL로부터 워커를 생성하려고 하면 각 페이지는 완전히 별개의 워커로 움직인다.

p.361 ~ 362 참고

### 11.1.1 워커 환경

워커 내부에서는 메인 프로그램의 자원에 접근 불가  
전역 변수는 물론이고 페이지 DOM 등 여타 자원도 접근 불가

하지만 워커는 네트워크 작업과 타이머 설정이 가능하며 중요한 전역 변수/특성을 자체 복사하여 접근 가능

워커에 추가 자바스크립트를 읽어들이려면 importScripts()를 사용하면 됨

스크립트는 동기적으로 읽기 때문에 importScripts()를 호출하면 해당 파일을 완전히 읽고 실행할 때까지 나머지 워커 코드는 실행이 중지됨

웹 워커의 주요 용도

- 처리 집약적 수학 계산
- 대용량 데이터 세트 정렬
- 데이터 작업
- 트래픽 높은 네트워크 통신

### 11.1.2 데이터 전송

웹 워커의 네 가지 주요 용도에는 공통점이 있음  
이벤트 체계를 바탕으로 스레드 간 장벽을 넘어 대량의 데이터가 양방향 전송되어야 하는 요건

초기에는 전체 데이터를 문자열 값으로 직렬화하는 방법뿐이었음  
양방향 직렬화로 인해 속도가 떨어지는 것도 문제지만 데이터 복사 과정에서 메모리 사용량이 엄청나게 늘어나는 단점도 있었음

다행히 지금은 더 나은 방법들이 존재

어떤 객체를 전달하면 수신측에서는 '구조화된 복제 알고리즘'으로 객체를 복사/복제  
이 알고리즘은 상당히 정교해서 환형 참조 객체도 복제 가능  
객체 <-> 문자열 변환 비용은 어쩔 수 없지만 이 알고리즘을 쓰면 메모리에 사본을 둘 수 있음

데이터 세트 규모가 방대하면 '트랜스퍼러블 객체'를 고려하는 것이 좋음  
데이터 자체는 그대로 두고 객체의 소유권만 전송하는 방식  
어떤 객체가 워커로 변신하고 나면 원래 위치에서는 텅 빈, 접근할 수 없는 객체가 되기 때문에 공유 스코프에서의 위험 요소를 제거할 수 있음  
물론 소유권 전송은 양방향 모두 가능

### 11.1.3 공유 워커

같은 페이지에 탭을 여러 개 읽어들이는 웹 사이트/앱에서는 마땅히 전용 워커가 중복되는 걸 최대한 방지하여 시스템 자원 점유율을 낮춰야 함  
가장 흔한 자원 제약은 네트워크 소켓 접속으로, 브라우저가 단일 호스트에 동시 접속할 수 있는 개수 제한을 말함  
물론, 단일 클라이언트의 다중 접속 제한은 서버 자원 요건을 완화시키는데 도움이 됨

이 경우 웹 사이트와 앱의 페이지 인스턴스가 서로 공유할 수 있는 하나의 중앙 워커를 두는 것이 좋음

p. 365 ~ 366 참고

### 11.1.4 웹 워커 폴리필

자바스크립트 프로그램의 병렬 실행 시 웹 워커의 성능은 상당히 매력적이지만 실행 환경이 비호환 구형 브라우저인 경우도 감안해야 함  
워커는 API고 구문은 아니라서 어느 정도 폴리필이 가능

워커를 지원하지 않는 브라우저는 성능상 멀티스레딩을 흉내조차 낼 수 없음

자바스크립트 비동기성의 근원은 이벤트 루프 큐이므로 타이머로 워커를 강제 조작하여 비동기성을 주는 방법이 있음  
그런 다음 워커 API를 폴리필하면 됨

## 11.2 SIMD

SIMD는 '데이터 병행성'을 나타내는 형식으로, 웹 워커의 '작업 병행성'과는 대조되는 개념

SIMD는 스레드 병행성을 제공하지 않음  
대신 현대 CPU는 숫자 '벡터'와 모든 숫자에 병렬 연산이 가능한 명령어 세트를 이용하여 SIMD 기능을 제공

SIMD 자바스크립트는 단축 벡터 타입과 API를 자바스크립트 코드의 일부분처럼 사용하는데, 이러한 SIMD 구동 시스템은 처리할 작업들을 CPU 동등체로 직접 매핑함  
병렬화하지 않은 작업은 SIMD 아닌 시스템에 '심'하여 대체

데이터 집약적 애플리케이션은 보통 수학 계산을 병렬로 처리하므로 뚜렷한 성능 향상 기대 가능

## 11.3 asm.js

asm.js는 자바스크립트 언어에서 고도로 최적화 가능한 부분 집합을 말함  
최적화하기 어려운, 특정한 체계와 패턴을 방지한 asm.js식 코드는 자바스크립트 엔진이 인식하여 아주 공격적으로 저수준 최적화를 하는 등의 특별히 조치를 함

p. 368 참고

### 11.3.1 asm.js 최적화

asm.js 최적화를 이해하려면 먼저 타입과 강제변환을 알아야 함  
자바스크립트 엔진이 다양한 연산 도중 상이한 타입의 변수 값들을 추적하면서 필요할 경우 타입 간 강제변환을 처리하는데 프로그램 최적화를 방해하는 잡다한 요소가 너무 많음

p. 369 ~ 370 참고

### 11.3.2 asm.js 모듈

메모리 할당, 가비지 콜렉션, 스코프 접근은 늘 자바스크립트 성능 문제의 논란거리  
그 해결 방안으로 asm.js에서는 더 정형화한 asm.js '모듈'을 선언

asm.js 모듈을 단순히 렉시컬 스코프를 통해 전역 객체를 쓰는 대신 필요한 심볼을 가져오기 위해 엄격하게 규정된 네임스페이스를 분명히 전달  
window 객체는 asm.js 모듈이 의도한 바와 잘 맞는 기본 stdlib 객체지만 더 제한된 객체를 만들 수도 있음

또, 힙을 반드시 선언하고 전달해서 asm.js 모듈이 메모리 천을 일으키지 않고 사전 예약된 공간을 사용하도록 해야 함

p. 370 ~ 372 참고

## 11.4 정리하기

프로그램 수준에서 성능을 개선할 수 있는 방안 3가지

1. 웹 워커
2. SIMD
3. asm.js
