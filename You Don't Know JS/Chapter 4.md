# Chapter 4. 클래스와 객체의 혼합

## 4.1 클래스 이론

클래스와 상속은 특정 형태의 코드와 구조를 형성하며 실생활 영역의 문제를 소프트웨어로 모델링 하기 위한 방법

객체 지향 또는 클래스 지향 프로그래밍에서 데이터는 자신을 기반으로 하는 실행되는 작동과 연관되므로 데이터와 작동을 함게 잘 감싸는 것이 올바른 설계라고 강조함
정규 컴퓨터 과학에서는 이를 자료 구조라고 표현

클래스는 특정 자료 구조를 분류하는 용도로 사용
즉, 일반적인 기준 정의에서 세부적이고 구체적인 변형으로서의 자료 구조를 도출하는 것

다형성은 또 다른 클래스의 핵심 개념으로 부모 클래스에 뭉뚱그려 정의된 작동을 자식 클래스에서 좀 더 구체화하여 오버라이드하는 것을 뜻함
사실 오버라이드된 작동에서 기반 작동을 참조할 수 있는 것은 이런 상대적 다형성 덕분

클래스 이론에서는 어떤 작동이 담긴 메서드의 이름을 부모와 자식 클래스 모두 똑같이 공유하여 자식 클래스 메서드가 부모 클래스 메서드를 오버라이드하라고 권장함
But, 자바스크립트에서 이렇게 하면 예기치 못한 결과를 초래하기도 함

### 4.1.1 클래스 디자인 패턴

순회자, 관찰자, 팩토리, 싱글턴 등의 유명한 객체 지향 디자인 패턴들이 워낙 자주 인용되는 탓에 클래스 역시 디자인 패턴의 일종이란 생각은 한 번도 해본 적이 없을 것임

절차적 프로그래밍이란 상위 수준의 추상화 없이 다른 함수를 호출하는 프로시저로만 코드를 구성하는 프로그래밍 기법

함수형 프로그래밍을 경험해 봤다면 클래스가 단지 많이 쓰는 서너 개 디자인 패턴 중 하나라는 사실 또한 잘 알고 있을 것임
하지만 대부분 독자에게 클래스가 과연 모든 코드의 근본적인 기초일까 아니면 코드를 선택적으로 추상화한 것일까란 의문을 품는 자체가 어색하게 느껴질 것임

몇몇 언어는 선택의 여지가 없어 만물이 다 클래스
C/C++나 PHP 같은 언어는 절차적 구문과 클래스 지향 구문을 함께 제공하므로 개발자가 스타일을 선택할 수 있음

### 4.1.2 자바스크립트 클래스

꽤 오래전부터 클래스와 비슷하게 생긴 구문 요소도 갖추고 있고 최근 ES6부터는 아예 class라는 키워드가 명세에 정식으로 추가됨
하지만 자바스크립트에는 클래스 존재 X

클래스는 디자인 패턴이므로 클래스 기능과 얼추 비슷하게 구현하는 것은 가능
자바스크립트도 계속해서 클래스 디자인 패턴을 실현하려는 노력이 있었음

But, 클래스처럼 보이는 구문일 뿐이며 개발자들이 클래스 디자인 패턴으로 코딩할 수 있도록 자바스크립트 체계를 억지로 고친 것에 불과
전혀 다른 방식으로 작동함

클래스는 소프트웨어 디자인 패턴 중 한 가지 옵션일 뿐이므로 자바스크립트에서 클래스를 쓸지 말지는 결국 자신이 결정할 문제


## 4.2 클래스 체계

대부분 클래스 지향 언어의 '표준 라이브러리'는 '스택' 자료 구조를 Stack 클래에 구현해놓음
Stack 클래스 내부에는 데이터를 저장하는 변수 세트가 있고 다른 코드에서 데이터와 상호 작용할 수 있도록 외부에서 접근 가능한 작동 모음을 제공

But, Stack 클래스에서 실제로 어떤 작업을 직접 수행하는 것은 아님
Stack 클래스는 모든 스택이라면 마땅히 해야 할 기능을 추상화한 것일 뿐 그 자체가 스택은 아님
stack 클래스를 인스턴스화해야 비로소 작업을 수행할 구체적인 자료 구조가 마련됨

### 4.2.1 건축

클래스는 건축에서 청사진에 해당
개발자가 상호 작용할 실제 객체는 클래스라는 붕어빵 틀에서 구워냄
이 '구워냄'의 최종 결과가 인스턴스라는 객체고 개발자는 객체 메서드를 직접 호출하거나 공용 데이터 프로퍼티에 접근
객체는 클래스에 기술된 모든 특성을 그대로 가진 사본

객체 인스턴스를 통해 클래스에 직접 접근하여 어떤 조작을 가할 일은 거의 없지만 적어도 어느 클래스로부터 구워진 객체 인스턴스인지 그 출처를 식별하는 일은 어렵지 않음

객체 인스턴스와 출처(클래스) 간의 간접적인 관계보다 클래스와 객체 인스턴스의 직접적인 관계를 따져보는 게 좀 더 유용함
클래스는 복사 과정을 거쳐 객체 형태로 인스턴스화

### 4.2.2 생성자

인스턴스는 보통 클래스명과 같은 이름의 생성자라는 특별한 메서드로 생성
생성자의 임무는 인스턴스에 필요한 정보 초기화

```javascript
class CoolGuy {
	specialTrick = nothing;
	
	CoolGuy(trick) {
		specialTrick = trick;
	}
	showOff() {
		output("이게 내 장기랍니다: ", specialTrick);
	}
}

Joe = new CoolGuy('카드 마술');
Joe.showOff(); // 이게 내 장기랍니다: 카드 마술
```

CoolGuy 클래스엔 생성자 CoolGuy()가 있어서 new CoolGuy()를 하면 실제로 이 생성자가 호출됨
생성자의 반환 값은 객체이므로 showOff() 메서드를 호출하면 CoolGuy의 장기가 뭔지 알 수 있음

생성자는 클래스에 속한 메서드로, 클래스명과 같게 명명하는 것이 일반적
그리고 새로운 클래스 인스턴스를 생성할 거라는 신호를 엔진이 인지할 수 있도록 항상 new 키워드를 앞에 붙여 생성자를 호출함

## 4.3 클래스 상속

클래스 지향 언어에서는 자체로 인스턴스화할 수 있는 클래스는 물론이고 첫 번재 클래스를 상속받은 두 번째 클래스를 정의할 수 있음
이때 첫 번째 클래스를 '부모 클래스', 두 번째 클래스를 '자식 클래스'라고 통칭

자식 클래스는 부모 클래스에서 완전히 떨어진 별개의 클래스로 정의됨
부모로부터 복사된 초기 버전의 작동을 고스란히 간직하고 있지만 물려받은 작동을 전혀 새로운 방식으로 오버라이드 가능

### 4.3.1 다형성

다형성은 '상대적'이란 관점에서 한 메서드가 상위 수준의 상속 체계에서 다른 메서드를 참조할 수 있게 해주는 아이디어
'상대적'이라고 한 이유는 접근할 상속 수준에 대한 절대적인 기준이 없는 상태에서 레퍼런스를 거슬러 올라가기 때문

대부분 언어는 inherited 대신 super라는 키워드를 사용하며, 이는 "superclass"를 현재 클래스의 부모/조상이라고 간주하는 것임

같은 이름의 메서드가 상속 연쇄의 수준별로 다르게 구현되어 있고 이 중 어떤 메서드가 적절한 호출 대상인지 자동으로 선택하는 것 또한 다형성의 특징

***자식 클래스의 생성자가 super 키워드로 직접 부모 클래스의 생성자를 참조하는 것 또한 전통적인 클래스 지향 언어에서 지원하는 기능이다. 진짜 클래스에서 생성자는 클래스의 한 부분이어서 대체로 그렇지만 자바스크립트는 정반대다. 외려 '클래스'가 생성자에 속한다고 보는 게 더 정확하다. 자바스크립트의 부모/자식 관계는 각 생성자의 .prototype 객체에만 기술되므로 막상 생성자 당사자는 직접적인 연관이 없으며 서로를 참조할 방법이 아예 없다.***

클래스를 상속하면 자식 클래스에는 자신의 부모 클래스를 가리키는 상대적 레퍼런스가 주어지는데, 바로 이 레퍼런스를 보통 super라고 함

클래스 상속은 한 마디로 '복사'

### 4.3.2 다중 상속

일부 클래스 지향 언어에서는 복수의 '부모' 클래스에서 '상속'받을 수 있음
다중 상속은 부모 클래스 각각의 정의가 자식 클래스로 복사된다는 의미

하지만, 다중 상속이 가능하다면 참조할 때 문제가 발생 가능
두 부모 클래스 모두 똑같은 이름의 메서드가 존재할 때 어느 부모 클래스의 메서드를 참조해야 하는 지가 문제

자바스크립트는 한 마디로 '다중 상속' 기능 따위는 아예 처음부터 지원하지 않았음