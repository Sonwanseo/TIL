# Chapter 9. 프라미스

프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그다음에 무슨 일을 해야 할지 스스로 결정할 수 있는 체계가 바로 프라미스

## 9.1 프라미스란

### 9.1.1 미랫값

##### 지금값과 나중값

'지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화하면 됨

물론, 이런 정교하지 않은 콜백식 접근법은 손봐야 할 부분이 많음

##### 프라미스 값

```javascript
function add(xPromise, yPromise) {
  // 'Promise.all([])'는 프라미스 배열을 인자로 받아
  // 프라미스들이 모두 귀결될 때까지 기다렸다가
  // 새 프라미스를 만들어 반환하는 함수다.
  return (
    Promise.all([xPromise, yPromise])

      // 프라미스가 귀결되면 'X'와 'Y' 값을 받아 더한다.
      .then(function (values) {
        // 'values'는 앞에서 귀결된 프라미스가
        // 건네준 메시지 배열이다.
        return values[0] + values[1];
      })
  );
}

// 'fetchX()'와 'fetchY()'는 제각기 값을 가진
// 프라미스를 반환하는 데, 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
  // 두 숫자의 합이 담긴 프라미스를 받는다.
  // 이제 반환된 프라미스가 귀결될 때까지 대기하기 위해
  // 'then()'을 연쇄 호출한다.

  .then(function (sum) {
    console.log(sum); // 더 쉽다!
  });
```

fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값을 add()에 전함  
두 프라미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화함  
덕분에 미랫값 X, Y는 시간 독립적으로 추론 가능

두 번째 계층은 add()가 만들어 반환한 프라미스로 then()을 호출하고 대기  
add()가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 add()안에 숨어 있음

**_add()에서 Promise.all([])을 호출하여 프라미스를 생성한다. .then()을 연쇄 호출하면 또 다른 프라미스가 생성되는데, return values[0] + values[1] 줄은 즉시 귀결되므로 add() 호출 끝에서 연쇄된 then() 호출은 실제로 Promise.all([])이 생성한 첫 번째 프라미스가 아닌 add()가 반환한 두 번째 프라미스에서 작동한다. 그리고 두 번째 then() 끝에서는 더는 연쇄 호출을 하진 않았지만 then() 역시 프라미스를 하나 더 생성하므로 뒷부분에서 이 프라미스를 사용/감지할 수 있다._**

항상 귀결 값을 프로그램이 결정짓는 이룸(fulfillment) 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 함

프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받음

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 그래서 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있음

또한, 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있음

**_프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프라미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프라미스 귀결에 영향을 줄 수 없다. '불변셩'은 프라미스 체계의 가장 근본적이고 중요한 부분을 차지하는 핵심이다._**

프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치임

### 9.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'하기 위한 체계라 볼 수 있음

콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성림됨  
하지만 프라미스에서는 이 관계가 역전되어 foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행됨

```javascript
foo(x) {
    // 뭔가 시간이 제법 걸리는 일을 시작한다.
}

foo(42);

on(foo "완료") {
    // 이제 다음 단꼐로 갈 수 있다!
}

on(foo "에러") {
    // 어랏, 'foo()'에서 뭔가 잘못됐다.
}
```

foo()를 부른 뒤 2개의 이벤트 리스너를 설정

콜백 함수가 실행되면 제어의 역전이 발생함  
But, 프라미스는 콜백 패턴을 뒤집으므로 제어의 역전을 역전함  
즉, 호출부가 제어권을 가지게 됨

##### 프라미스 '이벤트'

**_리스닝 중인 프라미스 귀결 '이벤트'는 엄밀히 말해서 이벤트가 아니고 '완료'나 '에러'라고 하지 않는 게 보통이다. 대신에 then()을 통한 'then' 이벤트의 등록이며, 더 정확히 말하면 '이룸', '버림' 이벤트를 등록하는 것이다._**

**_new Promise(function() {})는 '생성자 노출' 패턴의 전형적인 모습이다. 전달된 function은 즉시 실행되고 resolve, reject라고 이름 붙인 인자 2개를 받는다. 이 두 인자가 바로 프라미스의 귀결 함수다. resolve()는 이룸을, reject()는 버림을 각각 나타낸다._**

## 9.2 데이너블 덕 타이핑

new Promise() 구문으로 생성된 프라미스는 p instanceof Promise로 확인

사실 프라미스 값은 주로 다른 브라우저 창에서 넘겨받는데, 현재 윈도우/프레임에 있는 프라미스와는 동떨어진 그들만의 프라미스이므로 프라미스 인스턴스 체크만으로는 제대로 확인할 수 없음

게다가 외부 라이브러리/프레임워크 중에는 ES6 Promise가 아닌 고유한 방법으로 구현한 프라미스를 사용할 가능성도 존재  
그리고 구식 브라우저에서 라이브러리 형태로 프라미스를 사용할 수도 있음

진짜 프라미스는 then() 메서드를 가진, '데너블'이라는 객체 또는 함수를 정의하여 판별하는 것으로 규정됨  
데니블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주

어떤 값이 타입을 그 형태를 보고 짐작하는 타입 체크를 '덕 타이핑'이라 함

프라미스를 then()이라는 이름의 함수가 정의된 임의의 객체/함수로 이루고 싶지만 이 객체/함수를 프라미스/데너블로서 다루지 않아도 되는가  
답은 X  
자바스크립트 엔진이 데너블이라고 자동 인식하여 특별한 규칙을 적용함

```javascript
var o = { then: function () {} };

// 'v'를 'o'의 '[[Prototype]]'에 연결한다.
var v = Objec.create(o);

v.someStuff = "cool";
v.otherStuff = "not so cool";
v.hasOwnProperty("then"); // false
```

v는 then 메서드가 정의된 개체와 [[Prototype]] 연결된 별개의 객체  
따라서 데너블 덕 타이핑 감정 결과 v는 데너블로 판정받게 됨

**_프라미스 판별 방법이 데너블 덕 타이핑이 유일한 건 아니다. '브랜딩' 또는 '안티-브랜딩' 같은 최악의 경우를 가정한 다른 방법도 있다. 하지만 만사가 다 절망적이고 어두운 것만은 아니다. 뒤이어 나오지만 데너블 덕 타이핑이 유용할 때도 있다. 다만 프라미스 아닌 객체를 프라미스로 오판할 경우 데너블 덕 타이핑은 독이 될 수 있음을 유의하자._**

## 9.3 프라미스 믿음

콜백만 사용한 코드의 믿음성 문제

- 너무 일찍 콜백을 호출
- 너무 늦게 콜백을 호출
- 너무 적게, 아니면 너무 많이 콜백을 호출
- 필요한 환경/인자를 정상적으로 콜백에 전달 못함
- 발생 가능한 예외/에러를 무시함

프라미스 특성은 이와 같은 모든 일들에 대해 유용하고 되풀이하여 쓸 수 있는 해결책을 제시하게끔 설계됨

### 9.3.1 너무 빨리 호출

같은 작업인데도 어떨 때는 동기적으로, 어떨 때는 비동기적으로 끝나 결국 경합 조건에 이르게 되는, 자르고 현상을 일으킬 코드인지 확인하는 문제

프라미스는 바로 이루어져도 프라미스의 정의상 동기적으로 볼 수 없으니 이 문제는 영향받지 않음

따라서 then()을 호출하면 프라미스가 이미 귀결된 이후라 해도 then()에 건넨 콜백은 항상 비동기적으로만 부름

### 9.3.2 너무 늦게 호출

전과 비슷  
프라미스 then()에 등록한 콜백은 새 프라미스가 생성되면서 resolve(), reject() 중 어느 한 쪽은 자동 호출하도록 스케줄링됨  
이렇게 스케줄링된 두 콜백은 다음 비동기 시점에 예상대로 실행될 것

동기적인 관찰은 불가능하므로 어떤 동기적인 작업 연쇄가 실제로 예정된 다른 콜백의 실행을 지연시키는 방향으로 움직일 수는 없음  
즉, 프라미스가 귀결되면 then()에 등록된 콜백들이 그다음 비동기 기회가 찾아왔을 때 순서대로 실행되며 어느 한 콜백 내부에서 다른 콜백의 호출에 영향을 주거나 지연시킬일은 없음

##### 프라미스 스케줄링의 기벽

But, 별개의 두 프라미스에서 연쇄된 콜백 사이의 상대적인 실행 순서는 장담할 수 없음

두 프라미스 p1, p2가 모두 귀결된 상태라면 p1.then(); p2.then();에서 p1 콜백이 p2 콜백보다 당연히 먼저 실행되어야 할 것 같지만 꼭 그렇지 않은 애매한 경우가 존재
이러한 문제로 애를 먹지 않으려면 여러 프라미스에 걸친 콜백의 순서/스케줄링에 의존해선 안됨

### 9.3.3 한번도 콜백을 안 호출

프라미스 스스로 귀결 사실을 알리지 못하게 막을 방도는 없음  
이룸/버림 콜백이 프라미스에 모두 등록된 상태라면 프라미스 귀결 시 둘 중 하나는 반드시 호출

But, 만을 프라미스 스스로 어느 쪽으로도 귀결되지 않는다면?  
이런 상황에서는 '경합'이라는 상위 수준의 추상화를 이용하면 프라미스로 해결 가능

### 9.3.4 너무 가끔, 너무 종종 호출

콜백의 호출 횟수는 당연히 '한 번'  
따라서 '너무 가끔'은 곧 0번 부른다는 뜻이므로 앞 절 내용과 같음

'너무 종종' 호출하는 경우  
프라미스는 정의상 단 한번만 귀결됨  
어떤 이유로 프라미스 생성 코드가 resolve(), reject() 중 하나 또는 모두를 여러 차례 호출하려고 하면 프라미스는 오직 최초의 귀결만 취하고 이후의 시도는 조용히 무시

프라미스는 딱 한 번만 귀결되기 때문에 then()에 등록한 콜백 또한 한 번씩만 호출됨

### 9.3.5 인자/환경 전달 실패

프라미스 귀결 값은 딱 하나뿐

명시적인 값으로 귀결되지 않으면 그 값은 undefined로 세팅됨  
하지만 프라미스는 모든 등록한 콜백으로 반드시 전해짐

여기서 주의할 점  
resolve(), reject() 함수를 부를 때 인자를 여러 개 넘겨도 두 번째 이후 인자는 그대로 무시

값을 여러 개 넘기고 싶다면 배열이나 객체로 감싸야 함

자바스크립트 함수는 자신이 정의된 스코프의 클로저를 항상 간직하므로 클로저를 통해 얼마든지 계속 주변 상태에 접근 가능

### 9.3.6 에러/예외 삼키기

어떤 '이유'로 프라미스를 버리면 그 값은 버림 콜백으로 전달됨

하지만 프라미스가 생성 중 또는 귀결을 기다리는 도중 언제라도 TypeError, ReferenceError 등의 자바스크립트 에러가 나면 예외를 잡아 주어진 프라미스를 강제로 버림

에러 아닌 요소는 비동기적이면서 에러가 나면 동기적으로 반응하여, 앞으로 일어날지 모를 문제를 효과적으로 차단할 수 있기 때문에 매우 중요한 세부분임  
프라미스는 자바스크립트 예외조차도 비동기적 작동으로 바꾸어 경합 조건을 상당히 줄임

### 9.3.7 미더운 프라미스?

의심할 여지 없이 프라미스는 콜백을 완전히 없애기 위한 장치가 아님  
단지 프라미스는 콜백을 넘겨주는 위치만 달리할 뿐

즉시값또는 프라미스 아닌/데너블 아닌 값을 Promise.resolve()에 건네면 이 값으로 이루어진 프라미스를 얻게 됨

Promise.resolve()에 진짜 프라미스가 넘어가도 결과는 마찬가지

더욱 중요한 사실은, 프라미스가 아닌 데너블 값을 Promise.resolve()에 주면 일단 그 값을 풀어보고 최종적으로 프라미스 아닌 것 같은 구체적인 값이 나올 때가지 계속 풀어본다는 점

Promise.resolve()는 데너블을 인자로 받아 데너블 아닌 값이 발견될 때까지 풀어봐서 믿을 만한 진짜 프라미스를 즉석에서 내놓음  
진짜 프라미스 값을 넘기면 도로 내놓으니까 믿음성을 확보하기 위해 Promise.resolve()를 거친다 해서 단점이 될 만한 요소가 전혀 없음

**_Promise.resolve()로 일반 함수의 반환 값을 감싸면 함수 호출을 정규화하여 비동기 작업으로 잘 작동하게 할 수 있다는 부수 효과도 있다. 이를테면 foo(42)가 어떨 때는 즉시값을, 어떨 때는 프라미스일 경우 Promise.resolve(foo(42))로 감싸면 항상 결괏값이 프라미스로 고정된다. 자르고를 미연에 방지하여 더 나은 코드로 개선된 것이다._**

### 9.3.8 믿음 형성

프라미스는 콜백에 '믿음'의의미를 증강시킨 패턴으로 좀 더 타당하고 미더운 방식으로 작동함
