# Chapter 9. 프라미스

프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그다음에 무슨 일을 해야 할지 스스로 결정할 수 있는 체계가 바로 프라미스

## 9.1 프라미스란

### 9.1.1 미랫값

##### 지금값과 나중값

'지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화하면 됨

물론, 이런 정교하지 않은 콜백식 접근법은 손봐야 할 부분이 많음

##### 프라미스 값

```javascript
function add(xPromise, yPromise) {
  // 'Promise.all([])'는 프라미스 배열을 인자로 받아
  // 프라미스들이 모두 귀결될 때까지 기다렸다가
  // 새 프라미스를 만들어 반환하는 함수다.
  return (
    Promise.all([xPromise, yPromise])

      // 프라미스가 귀결되면 'X'와 'Y' 값을 받아 더한다.
      .then(function (values) {
        // 'values'는 앞에서 귀결된 프라미스가
        // 건네준 메시지 배열이다.
        return values[0] + values[1];
      })
  );
}

// 'fetchX()'와 'fetchY()'는 제각기 값을 가진
// 프라미스를 반환하는 데, 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
  // 두 숫자의 합이 담긴 프라미스를 받는다.
  // 이제 반환된 프라미스가 귀결될 때까지 대기하기 위해
  // 'then()'을 연쇄 호출한다.

  .then(function (sum) {
    console.log(sum); // 더 쉽다!
  });
```

fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값을 add()에 전함  
두 프라미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화함  
덕분에 미랫값 X, Y는 시간 독립적으로 추론 가능

두 번째 계층은 add()가 만들어 반환한 프라미스로 then()을 호출하고 대기  
add()가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 add()안에 숨어 있음

**_add()에서 Promise.all([])을 호출하여 프라미스를 생성한다. .then()을 연쇄 호출하면 또 다른 프라미스가 생성되는데, return values[0] + values[1] 줄은 즉시 귀결되므로 add() 호출 끝에서 연쇄된 then() 호출은 실제로 Promise.all([])이 생성한 첫 번째 프라미스가 아닌 add()가 반환한 두 번째 프라미스에서 작동한다. 그리고 두 번째 then() 끝에서는 더는 연쇄 호출을 하진 않았지만 then() 역시 프라미스를 하나 더 생성하므로 뒷부분에서 이 프라미스를 사용/감지할 수 있다._**

항상 귀결 값을 프로그램이 결정짓는 이룸(fulfillment) 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 함

프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받음

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 그래서 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있음

또한, 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있음

**_프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프라미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프라미스 귀결에 영향을 줄 수 없다. '불변셩'은 프라미스 체계의 가장 근본적이고 중요한 부분을 차지하는 핵심이다._**

프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치임

### 9.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'하기 위한 체계라 볼 수 있음

콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성림됨  
하지만 프라미스에서는 이 관계가 역전되어 foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행됨

```javascript
foo(x) {
    // 뭔가 시간이 제법 걸리는 일을 시작한다.
}

foo(42);

on(foo "완료") {
    // 이제 다음 단꼐로 갈 수 있다!
}

on(foo "에러") {
    // 어랏, 'foo()'에서 뭔가 잘못됐다.
}
```

foo()를 부른 뒤 2개의 이벤트 리스너를 설정

콜백 함수가 실행되면 제어의 역전이 발생함  
But, 프라미스는 콜백 패턴을 뒤집으므로 제어의 역전을 역전함  
즉, 호출부가 제어권을 가지게 됨
