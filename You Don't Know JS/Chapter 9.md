# Chapter 9. 프라미스

프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그다음에 무슨 일을 해야 할지 스스로 결정할 수 있는 체계가 바로 프라미스

## 9.1 프라미스란

### 9.1.1 미랫값

##### 지금값과 나중값

'지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화하면 됨

물론, 이런 정교하지 않은 콜백식 접근법은 손봐야 할 부분이 많음

##### 프라미스 값

```javascript
function add(xPromise, yPromise) {
  // 'Promise.all([])'는 프라미스 배열을 인자로 받아
  // 프라미스들이 모두 귀결될 때까지 기다렸다가
  // 새 프라미스를 만들어 반환하는 함수다.
  return (
    Promise.all([xPromise, yPromise])

      // 프라미스가 귀결되면 'X'와 'Y' 값을 받아 더한다.
      .then(function (values) {
        // 'values'는 앞에서 귀결된 프라미스가
        // 건네준 메시지 배열이다.
        return values[0] + values[1];
      })
  );
}

// 'fetchX()'와 'fetchY()'는 제각기 값을 가진
// 프라미스를 반환하는 데, 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
  // 두 숫자의 합이 담긴 프라미스를 받는다.
  // 이제 반환된 프라미스가 귀결될 때까지 대기하기 위해
  // 'then()'을 연쇄 호출한다.

  .then(function (sum) {
    console.log(sum); // 더 쉽다!
  });
```

fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값을 add()에 전함  
두 프라미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화함  
덕분에 미랫값 X, Y는 시간 독립적으로 추론 가능

두 번째 계층은 add()가 만들어 반환한 프라미스로 then()을 호출하고 대기  
add()가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 add()안에 숨어 있음

**_add()에서 Promise.all([])을 호출하여 프라미스를 생성한다. .then()을 연쇄 호출하면 또 다른 프라미스가 생성되는데, return values[0] + values[1] 줄은 즉시 귀결되므로 add() 호출 끝에서 연쇄된 then() 호출은 실제로 Promise.all([])이 생성한 첫 번째 프라미스가 아닌 add()가 반환한 두 번째 프라미스에서 작동한다. 그리고 두 번째 then() 끝에서는 더는 연쇄 호출을 하진 않았지만 then() 역시 프라미스를 하나 더 생성하므로 뒷부분에서 이 프라미스를 사용/감지할 수 있다._**

항상 귀결 값을 프로그램이 결정짓는 이룸(fulfillment) 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 함

프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받음

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 그래서 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있음

또한, 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있음

**_프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프라미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프라미스 귀결에 영향을 줄 수 없다. '불변셩'은 프라미스 체계의 가장 근본적이고 중요한 부분을 차지하는 핵심이다._**

프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치임

### 9.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'하기 위한 체계라 볼 수 있음

콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성림됨  
하지만 프라미스에서는 이 관계가 역전되어 foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행됨

```javascript
foo(x) {
    // 뭔가 시간이 제법 걸리는 일을 시작한다.
}

foo(42);

on(foo "완료") {
    // 이제 다음 단꼐로 갈 수 있다!
}

on(foo "에러") {
    // 어랏, 'foo()'에서 뭔가 잘못됐다.
}
```

foo()를 부른 뒤 2개의 이벤트 리스너를 설정

콜백 함수가 실행되면 제어의 역전이 발생함  
But, 프라미스는 콜백 패턴을 뒤집으므로 제어의 역전을 역전함  
즉, 호출부가 제어권을 가지게 됨

##### 프라미스 '이벤트'

**_리스닝 중인 프라미스 귀결 '이벤트'는 엄밀히 말해서 이벤트가 아니고 '완료'나 '에러'라고 하지 않는 게 보통이다. 대신에 then()을 통한 'then' 이벤트의 등록이며, 더 정확히 말하면 '이룸', '버림' 이벤트를 등록하는 것이다._**

**_new Promise(function() {})는 '생성자 노출' 패턴의 전형적인 모습이다. 전달된 function은 즉시 실행되고 resolve, reject라고 이름 붙인 인자 2개를 받는다. 이 두 인자가 바로 프라미스의 귀결 함수다. resolve()는 이룸을, reject()는 버림을 각각 나타낸다._**

## 9.2 데이너블 덕 타이핑

new Promise() 구문으로 생성된 프라미스는 p instanceof Promise로 확인

사실 프라미스 값은 주로 다른 브라우저 창에서 넘겨받는데, 현재 윈도우/프레임에 있는 프라미스와는 동떨어진 그들만의 프라미스이므로 프라미스 인스턴스 체크만으로는 제대로 확인할 수 없음

게다가 외부 라이브러리/프레임워크 중에는 ES6 Promise가 아닌 고유한 방법으로 구현한 프라미스를 사용할 가능성도 존재  
그리고 구식 브라우저에서 라이브러리 형태로 프라미스를 사용할 수도 있음

진짜 프라미스는 then() 메서드를 가진, '데너블'이라는 객체 또는 함수를 정의하여 판별하는 것으로 규정됨  
데니블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주

어떤 값이 타입을 그 형태를 보고 짐작하는 타입 체크를 '덕 타이핑'이라 함

프라미스를 then()이라는 이름의 함수가 정의된 임의의 객체/함수로 이루고 싶지만 이 객체/함수를 프라미스/데너블로서 다루지 않아도 되는가  
답은 X  
자바스크립트 엔진이 데너블이라고 자동 인식하여 특별한 규칙을 적용함

```javascript
var o = { then: function () {} };

// 'v'를 'o'의 '[[Prototype]]'에 연결한다.
var v = Objec.create(o);

v.someStuff = "cool";
v.otherStuff = "not so cool";
v.hasOwnProperty("then"); // false
```

v는 then 메서드가 정의된 개체와 [[Prototype]] 연결된 별개의 객체  
따라서 데너블 덕 타이핑 감정 결과 v는 데너블로 판정받게 됨

**_프라미스 판별 방법이 데너블 덕 타이핑이 유일한 건 아니다. '브랜딩' 또는 '안티-브랜딩' 같은 최악의 경우를 가정한 다른 방법도 있다. 하지만 만사가 다 절망적이고 어두운 것만은 아니다. 뒤이어 나오지만 데너블 덕 타이핑이 유용할 때도 있다. 다만 프라미스 아닌 객체를 프라미스로 오판할 경우 데너블 덕 타이핑은 독이 될 수 있음을 유의하자._**
