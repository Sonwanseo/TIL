# Chapter 9. 프라미스

프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그다음에 무슨 일을 해야 할지 스스로 결정할 수 있는 체계가 바로 프라미스

## 9.1 프라미스란

### 9.1.1 미랫값

##### 지금값과 나중값

'지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화하면 됨

물론, 이런 정교하지 않은 콜백식 접근법은 손봐야 할 부분이 많음

##### 프라미스 값

```javascript
function add(xPromise, yPromise) {
  // 'Promise.all([])'는 프라미스 배열을 인자로 받아
  // 프라미스들이 모두 귀결될 때까지 기다렸다가
  // 새 프라미스를 만들어 반환하는 함수다.
  return (
    Promise.all([xPromise, yPromise])

      // 프라미스가 귀결되면 'X'와 'Y' 값을 받아 더한다.
      .then(function (values) {
        // 'values'는 앞에서 귀결된 프라미스가
        // 건네준 메시지 배열이다.
        return values[0] + values[1];
      })
  );
}

// 'fetchX()'와 'fetchY()'는 제각기 값을 가진
// 프라미스를 반환하는 데, 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
  // 두 숫자의 합이 담긴 프라미스를 받는다.
  // 이제 반환된 프라미스가 귀결될 때까지 대기하기 위해
  // 'then()'을 연쇄 호출한다.

  .then(function (sum) {
    console.log(sum); // 더 쉽다!
  });
```

fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값을 add()에 전함  
두 프라미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화함  
덕분에 미랫값 X, Y는 시간 독립적으로 추론 가능

두 번째 계층은 add()가 만들어 반환한 프라미스로 then()을 호출하고 대기  
add()가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 add()안에 숨어 있음

**_add()에서 Promise.all([])을 호출하여 프라미스를 생성한다. .then()을 연쇄 호출하면 또 다른 프라미스가 생성되는데, return values[0] + values[1] 줄은 즉시 귀결되므로 add() 호출 끝에서 연쇄된 then() 호출은 실제로 Promise.all([])이 생성한 첫 번째 프라미스가 아닌 add()가 반환한 두 번째 프라미스에서 작동한다. 그리고 두 번째 then() 끝에서는 더는 연쇄 호출을 하진 않았지만 then() 역시 프라미스를 하나 더 생성하므로 뒷부분에서 이 프라미스를 사용/감지할 수 있다._**

항상 귀결 값을 프로그램이 결정짓는 이룸(fulfillment) 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 함

프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받음

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 그래서 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있음

또한, 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있음

**_프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프라미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프라미스 귀결에 영향을 줄 수 없다. '불변셩'은 프라미스 체계의 가장 근본적이고 중요한 부분을 차지하는 핵심이다._**

프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치임

### 9.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'하기 위한 체계라 볼 수 있음

콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성림됨  
하지만 프라미스에서는 이 관계가 역전되어 foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행됨

```javascript
foo(x) {
    // 뭔가 시간이 제법 걸리는 일을 시작한다.
}

foo(42);

on(foo "완료") {
    // 이제 다음 단꼐로 갈 수 있다!
}

on(foo "에러") {
    // 어랏, 'foo()'에서 뭔가 잘못됐다.
}
```

foo()를 부른 뒤 2개의 이벤트 리스너를 설정

콜백 함수가 실행되면 제어의 역전이 발생함  
But, 프라미스는 콜백 패턴을 뒤집으므로 제어의 역전을 역전함  
즉, 호출부가 제어권을 가지게 됨

##### 프라미스 '이벤트'

**_리스닝 중인 프라미스 귀결 '이벤트'는 엄밀히 말해서 이벤트가 아니고 '완료'나 '에러'라고 하지 않는 게 보통이다. 대신에 then()을 통한 'then' 이벤트의 등록이며, 더 정확히 말하면 '이룸', '버림' 이벤트를 등록하는 것이다._**

**_new Promise(function() {})는 '생성자 노출' 패턴의 전형적인 모습이다. 전달된 function은 즉시 실행되고 resolve, reject라고 이름 붙인 인자 2개를 받는다. 이 두 인자가 바로 프라미스의 귀결 함수다. resolve()는 이룸을, reject()는 버림을 각각 나타낸다._**

## 9.2 데이너블 덕 타이핑

new Promise() 구문으로 생성된 프라미스는 p instanceof Promise로 확인

사실 프라미스 값은 주로 다른 브라우저 창에서 넘겨받는데, 현재 윈도우/프레임에 있는 프라미스와는 동떨어진 그들만의 프라미스이므로 프라미스 인스턴스 체크만으로는 제대로 확인할 수 없음

게다가 외부 라이브러리/프레임워크 중에는 ES6 Promise가 아닌 고유한 방법으로 구현한 프라미스를 사용할 가능성도 존재  
그리고 구식 브라우저에서 라이브러리 형태로 프라미스를 사용할 수도 있음

진짜 프라미스는 then() 메서드를 가진, '데너블'이라는 객체 또는 함수를 정의하여 판별하는 것으로 규정됨  
데니블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주

어떤 값이 타입을 그 형태를 보고 짐작하는 타입 체크를 '덕 타이핑'이라 함

프라미스를 then()이라는 이름의 함수가 정의된 임의의 객체/함수로 이루고 싶지만 이 객체/함수를 프라미스/데너블로서 다루지 않아도 되는가  
답은 X  
자바스크립트 엔진이 데너블이라고 자동 인식하여 특별한 규칙을 적용함

```javascript
var o = { then: function () {} };

// 'v'를 'o'의 '[[Prototype]]'에 연결한다.
var v = Objec.create(o);

v.someStuff = "cool";
v.otherStuff = "not so cool";
v.hasOwnProperty("then"); // false
```

v는 then 메서드가 정의된 개체와 [[Prototype]] 연결된 별개의 객체  
따라서 데너블 덕 타이핑 감정 결과 v는 데너블로 판정받게 됨

**_프라미스 판별 방법이 데너블 덕 타이핑이 유일한 건 아니다. '브랜딩' 또는 '안티-브랜딩' 같은 최악의 경우를 가정한 다른 방법도 있다. 하지만 만사가 다 절망적이고 어두운 것만은 아니다. 뒤이어 나오지만 데너블 덕 타이핑이 유용할 때도 있다. 다만 프라미스 아닌 객체를 프라미스로 오판할 경우 데너블 덕 타이핑은 독이 될 수 있음을 유의하자._**

## 9.3 프라미스 믿음

콜백만 사용한 코드의 믿음성 문제

- 너무 일찍 콜백을 호출
- 너무 늦게 콜백을 호출
- 너무 적게, 아니면 너무 많이 콜백을 호출
- 필요한 환경/인자를 정상적으로 콜백에 전달 못함
- 발생 가능한 예외/에러를 무시함

프라미스 특성은 이와 같은 모든 일들에 대해 유용하고 되풀이하여 쓸 수 있는 해결책을 제시하게끔 설계됨

### 9.3.1 너무 빨리 호출

같은 작업인데도 어떨 때는 동기적으로, 어떨 때는 비동기적으로 끝나 결국 경합 조건에 이르게 되는, 자르고 현상을 일으킬 코드인지 확인하는 문제

프라미스는 바로 이루어져도 프라미스의 정의상 동기적으로 볼 수 없으니 이 문제는 영향받지 않음

따라서 then()을 호출하면 프라미스가 이미 귀결된 이후라 해도 then()에 건넨 콜백은 항상 비동기적으로만 부름

### 9.3.2 너무 늦게 호출

전과 비슷  
프라미스 then()에 등록한 콜백은 새 프라미스가 생성되면서 resolve(), reject() 중 어느 한 쪽은 자동 호출하도록 스케줄링됨  
이렇게 스케줄링된 두 콜백은 다음 비동기 시점에 예상대로 실행될 것

동기적인 관찰은 불가능하므로 어떤 동기적인 작업 연쇄가 실제로 예정된 다른 콜백의 실행을 지연시키는 방향으로 움직일 수는 없음  
즉, 프라미스가 귀결되면 then()에 등록된 콜백들이 그다음 비동기 기회가 찾아왔을 때 순서대로 실행되며 어느 한 콜백 내부에서 다른 콜백의 호출에 영향을 주거나 지연시킬일은 없음

##### 프라미스 스케줄링의 기벽

But, 별개의 두 프라미스에서 연쇄된 콜백 사이의 상대적인 실행 순서는 장담할 수 없음

두 프라미스 p1, p2가 모두 귀결된 상태라면 p1.then(); p2.then();에서 p1 콜백이 p2 콜백보다 당연히 먼저 실행되어야 할 것 같지만 꼭 그렇지 않은 애매한 경우가 존재
이러한 문제로 애를 먹지 않으려면 여러 프라미스에 걸친 콜백의 순서/스케줄링에 의존해선 안됨

### 9.3.3 한번도 콜백을 안 호출

프라미스 스스로 귀결 사실을 알리지 못하게 막을 방도는 없음  
이룸/버림 콜백이 프라미스에 모두 등록된 상태라면 프라미스 귀결 시 둘 중 하나는 반드시 호출

But, 만을 프라미스 스스로 어느 쪽으로도 귀결되지 않는다면?  
이런 상황에서는 '경합'이라는 상위 수준의 추상화를 이용하면 프라미스로 해결 가능

### 9.3.4 너무 가끔, 너무 종종 호출

콜백의 호출 횟수는 당연히 '한 번'  
따라서 '너무 가끔'은 곧 0번 부른다는 뜻이므로 앞 절 내용과 같음

'너무 종종' 호출하는 경우  
프라미스는 정의상 단 한번만 귀결됨  
어떤 이유로 프라미스 생성 코드가 resolve(), reject() 중 하나 또는 모두를 여러 차례 호출하려고 하면 프라미스는 오직 최초의 귀결만 취하고 이후의 시도는 조용히 무시

프라미스는 딱 한 번만 귀결되기 때문에 then()에 등록한 콜백 또한 한 번씩만 호출됨

### 9.3.5 인자/환경 전달 실패

프라미스 귀결 값은 딱 하나뿐

명시적인 값으로 귀결되지 않으면 그 값은 undefined로 세팅됨  
하지만 프라미스는 모든 등록한 콜백으로 반드시 전해짐

여기서 주의할 점  
resolve(), reject() 함수를 부를 때 인자를 여러 개 넘겨도 두 번째 이후 인자는 그대로 무시

값을 여러 개 넘기고 싶다면 배열이나 객체로 감싸야 함

자바스크립트 함수는 자신이 정의된 스코프의 클로저를 항상 간직하므로 클로저를 통해 얼마든지 계속 주변 상태에 접근 가능

### 9.3.6 에러/예외 삼키기

어떤 '이유'로 프라미스를 버리면 그 값은 버림 콜백으로 전달됨

하지만 프라미스가 생성 중 또는 귀결을 기다리는 도중 언제라도 TypeError, ReferenceError 등의 자바스크립트 에러가 나면 예외를 잡아 주어진 프라미스를 강제로 버림

에러 아닌 요소는 비동기적이면서 에러가 나면 동기적으로 반응하여, 앞으로 일어날지 모를 문제를 효과적으로 차단할 수 있기 때문에 매우 중요한 세부분임  
프라미스는 자바스크립트 예외조차도 비동기적 작동으로 바꾸어 경합 조건을 상당히 줄임

### 9.3.7 미더운 프라미스?

의심할 여지 없이 프라미스는 콜백을 완전히 없애기 위한 장치가 아님  
단지 프라미스는 콜백을 넘겨주는 위치만 달리할 뿐

즉시값또는 프라미스 아닌/데너블 아닌 값을 Promise.resolve()에 건네면 이 값으로 이루어진 프라미스를 얻게 됨

Promise.resolve()에 진짜 프라미스가 넘어가도 결과는 마찬가지

더욱 중요한 사실은, 프라미스가 아닌 데너블 값을 Promise.resolve()에 주면 일단 그 값을 풀어보고 최종적으로 프라미스 아닌 것 같은 구체적인 값이 나올 때가지 계속 풀어본다는 점

Promise.resolve()는 데너블을 인자로 받아 데너블 아닌 값이 발견될 때까지 풀어봐서 믿을 만한 진짜 프라미스를 즉석에서 내놓음  
진짜 프라미스 값을 넘기면 도로 내놓으니까 믿음성을 확보하기 위해 Promise.resolve()를 거친다 해서 단점이 될 만한 요소가 전혀 없음

**_Promise.resolve()로 일반 함수의 반환 값을 감싸면 함수 호출을 정규화하여 비동기 작업으로 잘 작동하게 할 수 있다는 부수 효과도 있다. 이를테면 foo(42)가 어떨 때는 즉시값을, 어떨 때는 프라미스일 경우 Promise.resolve(foo(42))로 감싸면 항상 결괏값이 프라미스로 고정된다. 자르고를 미연에 방지하여 더 나은 코드로 개선된 것이다._**

### 9.3.8 믿음 형성

프라미스는 콜백에 '믿음'의의미를 증강시킨 패턴으로 좀 더 타당하고 미더운 방식으로 작동함

## 9.4 연쇄 흐름

프라미스는 단일-단계 작업만을 대상으로 만들어진 체계가 아님  
프라미스는 여러 개를 길게 늘어놓으면 일련의 비동기 단계를 나타낼 수 있음

그 비결은 프라미스에 내재된 두 가지 작동 방식 덕분

- 프라미스에 then()을 부를 때마다 생성하여 반환하는 새 프라미스를 계속 연쇄할 수 있음
- then()의 이룸 콜백 함수가 반환한 값은 어떤 값이든 자동으로 연쇄된 프라미스의 이룸으로 세팅됨

```javascript
var p = Promise.resolve(21);

var p2 = p.then(function (v) {
  console.log(v); // 21

  // 'p2'는 이룸 (결괏값 '42')
  return v * 2;
});

// 'p2'를 연쇄한다.
p2.then(function (v) {
  console.log(v); // 42
});
```

v _ 2 (42)를 반환하면서 첫 번재 then() 호출이 만들어준 신생 프라미스 p2를 이룸  
p2의 then()을 호출하면 return v _ 2;에서 이룸값을 받음  
물론, p2.then()은 다시 새 프라미스를 생성하므로 다른 변수에 보관해도 됨

하지만 도중에 잠깐 임시로 쓸 변수를 자꾸 선언하는 건 다소 번거로움  
변수 선언 없이 연쇄 가능

```javascript
var p = Promise.resolve(21);

p.then(function (v) {
  console.log(v); // 21

  // 연쇄된 프라미스를 이룸 (결괏값은 '42')
  return v * 2;
})
  // 프라미스 연쇄
  .then(function (v) {
    console.log(v); // 42
  });
```

비동기 시퀀스 전체적으로 봤을 때 첫 번째 then()은 1단계, 두 번째 then()은 2단계에 각각 해당됨  
이전 단계 then()을 연쇄하면 새 프라미스가 자동으로 생성됨

프라미스 시퀀스가 각 단계마다 진짜 비동기적으로 작동하게 만드는 핵심은 Promise.resolve()에 넘긴 값이 어떤 최종값이 아닌 프라미스/데너블일 때 Promise.resolve()의 작동 로직임  
Promise.resolve()는 진짜 프라미스를 받으면 도로 뱉어내며, 데너블을 받으면 일단 한번 풀어보고 아니면 원하는 값이 나올 때까지 재귀적으로 계속 풀어봄

이룸/버림 처리기에서 데너블/프라미스를 반환해도 마찬가지로 풀어봄

프라미스 연쇄는 다단계 비동기 시퀀스에서 흐름 제어 뿐만 아니라 단계와 단계 사이에 메시지를 전달하는 채널로도 사용됨

만약 프라미스 연쇄의 어느 단계에서 문제가 발생한다면?  
에러/예외는 프라미스 단위로 한정되므로 전체 연쇄 어느 곳에서 난 에러라도 모두 잡아 바로 그 지점부터 '리셋'을 하여 연쇄를 다시 정상 가동시킴

프라미스의 then()을 부를 때 이룸 처리기만 넘기면 버림 처리기는 기본 처리기로 대체됨

기본 버림 처리기는 단순히 에러를 다시 던지는 역할을 함

then()에 온전한 이룸 처리기를 넘기지 않을 경우에도 기본 처리기로 자동 대체됨

기본 이룸 처리기는 받은 값을 다음 단계에 그대로 전하기만 함

흐름 제어를 연쇄할 수 있는 프라미스 고유의 특징

- then()을 호출하면 그 결과 자동으로 새 프라미스를 생성하여 반환함
- 이룸/버림 처리기 안에서 어떤 값을 반환하거나 예외를 던지면 이에 따라 새 프라미스가 귀결됨
- 이룸/버림 처리기가 반환한 프라미스는 풀린 상태로 그 귀결 값이 무엇이든 간에 결국 현재의 then()에서 반환된, 연쇄된 프라미스의 귀결 값이 됨

흐름 제어 연쇄가 유용한 것은 여러 프라미스가 함께 구성되는 방법에 따른 부수 효과라고 보는 편이 가장 정확  
프라미스가 비동기성을 정규화하고 시간 의존적인 값 상태를 캡슐화해준 덕분에 이렇게 유용한 방향으로 연쇄할 수 있게 된 것

### 9.4.1 용어 정의: 귀결, 이룸, 버림

```javascript
var p = new Promise(function (X, Y) {
  // X()는 이룸
  // Y()는 버림
});
```

콜백 2개를 넘기는데, 첫 번째는 프라미스가 이루어졌음을, 두 번째는 프라미스가 버려졌음을 표시하는 용도로 사용

'귀결'이란 '결과는 이룸 아니면 버림이다'라는 맥락으로 사용됨

Promise() 생성자의 첫 번째 콜백 인자는 데너블, 진짜 프라미스 중 하나를 풀어볼 것임

**_reject()는 resolve()와 달리 풀어보지 않는다. reject()에 프라미스/데너블 값을 넘기면 값 자체는 건드리지 않고 버림 사유로 세팅한다. 그럼 이어서 버림 처리기는 원래 즉시값 말고 reject()에 전해진 실제 프라미스/데너블을 수신한다._**

## 9.5 에러 처리

동기적인 try...catch 구문은 개발자들이 대부분 익숙한 가장 일반적인 에러 처리 형태  
아쉽게도 try...catch는 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물

콜백 세계에선 에러 처리 패턴에 관한 몇 가지 표준이 있는데, 그중 '에러-우선 콜백' 스타일을 알아보자

```javascript
function foo(cb) {
  setTimeout(function () {
    try {
      var x = baz.bar();
      cb(null); // 이룸!
    } catch (err) {
      cb(err);
    }
  }, 100);
}

foo(function (err, val) {
  if (err) {
    console.error(err);
  } else {
    console.log(val);
  }
});
```

**_이 예제에서 try...catch는 baz.bar() 호출 결과가 즉시 동기적으로 성공/실패한다는 전제하에서만 작동한다. baz.bar() 함수 자체가 비동기로 작동하면 그 내부에서 발생한 에러는 잡을 수 없다._**

foo() 함수에 전달한 콜백은 첫 번째 인자 err를 통해 에러 신호를 감지할 것

이런 식으로 비동기적 에러 처리를 구현할 수 있지만 여러 개를 조합하면 문제가 심각해짐  
수준이 제각각인 에러 우선 콜백이 if 문이 여기저기 널린 상태로 서로 뒤엉키다보면 결국 콜백 지옥이 발생

프라미스는 널리 알려진 '에러-우선 콜백' 대신 '분산-콜백' 스타일로 이룸/버림 각각의 콜백을 지정하여 에러 처리를 함

이러한 에러 처리 패턴은 표면적으로 아주 명쾌한 것 같지만 프라미스 에러 처리는 미묘한 부분이 숨겨져 있어서 완벽하기 이해하기가 쉽지 않음

**_프라미스 API를 잘못 사용해서 프라미스 생성 과정에서 에러가 나면 그 결과는 버림 프라미스가 아니라 바로 예외를 던진다. new Promise(null), Promise.all(), Promise.race(42) 등 프라미스 생성이 실패하는 대표적인 오용 사례들이 있다. 첫 단추부터 프라미스 API 사용 방법을 오해하여 프라미스를 온전히 만들지 못하면 버림 프라미스는 아무 의미가 없다._**

### 9.5.1 절망의 구덩이

프라미스 에러 처리는 분명히 '절망의 구덩이' 방식으로 설계되어 있음  
그래서 기본적으로 에러가 나도 프라미스 상태에 따라 무시할 수 있다고 보기 때문에 개발자가 깜빡 잊고 상태 감지를 하지 않으면 조용히 에러는 사라짐

사라진/버려진 프라미스의 침묵 속에 에러 또한 함께 파묻히는 걸 막으려면 반드시 프라미스 연쇄 끝부분에 catch()를 써야 한다고 주장하는 개발자들도 있음

그렇다고 무작정 연쇄 끝에 catch()를 하나 더 붙일 수는 없음  
이 함수 역시 실패할 가능성이 존재  
어쨌든 프라미스 연쇄의 마지막 단계에 방치된 프라미스에서 에러가 나면 잡히지 않고 매달려 있을 가능성은 항상 존재

### 9.5.2 잡히지 않는 에러 처리

일부 프라미스 라이브러리는 '전역 미처리 버림' 처리기 같은 것을 등록하는 메서드를 추가하여 전역 범위로 에러를 던지는 대신 이 메서드가 대신 호출되도록 설정  
그러나 잡히지 않은 에러인지 식별하기 위해 버림 직후 임의의 시간 동안 타이머를 걸어놓은 식으로 구현  
프라미스가 버려졌으나 타이머 작동 전 등록된 에러 처리기가 없으면 앞으로도 처리기를 등록하지 않겠다는 의사로 간주되어 에러는 잡히지 않음

대다수 사용 패턴을 보면 프라미스 버림 시점과 이를 감지하기까지의 지연 시간이 그다지 길지 않기 때문에 이 방법은 실제로 많은 라이브러리에서 잘 통함

그래서 프라미스 연쇄 끝에 done()을 붙여 완료 사실을 천명해야 한다고 조언하는 사람들도 존재  
done()은 프라미스를 생성, 반환하는 함수가 아니므로 done()에 넘긴 콜백이 존재하지도 않는 연쇄 프라미스에 문제를 알려줄 리 만무함

done() 버림 처리기 내부에서 에러가 나면 잡히지 않은 전역 에러로 던짐

가장 큰 문제점은 ES6 표준에 들어있지 않기 때문에 아무리 그럴싸해 보여도 믿을 만한 보편적인 해결 방안과는 거리가 있음

브라우저엔 개발자가 작성하는 코드로는 불가능한 고유한 기능이 있음  
브라우저는 언제 어떤 객체가 휴지통으로 직행하여 가비지 콜렉션될지 정확히 알고 추적할 수 있음  
따라서 브라우저는 프라미스 객체를 추적하면서 언제 가비지를 수거하면 될지 분명히 알고 있으며, 프라미스가 버려지면 그 사유가 논리적인, 잡히지 않은 에러이므로 개발자 콘솔창에 표시해야 할지 여부를 확실하게 결정할 수 있음

그러나 프라미스가 제대로 가비지 콜렉션되지 않으면 브라우저의 가비지 콜렉션 감지 기능은 도처에 널려있는 침묵 속의 버림 프라미스를 파악/진단하는 데 도움이 되지 않음

### 9.5.3 성공의 구덩이

- 기본적으로 프라미스는 그다음 잡/이벤트 루프 틱 시점에 에러 처리기가 등록되어 있지 않을 경우 모든 버림을 알리도록 되어 있음
- 감지되기 전까지 버림 프라미스의 버림 상태를 계속해서 유지하려면 defer()를 호출해서 해당 프라미스에 관한 자동 에러 알림 기능을 끔

프라미스가 버려지면 엔진은 기본적으로 개발자 콘솔창에 이 사실을 알림  
개발자는 암시적으로 버림 전에 에러 처리기를 등록하든지, 아니면 명시적으로 defer()를 호출하든지 하여 알림 기능을 끌 수 있음

```javascript
var p = Promise.reject("허걱").defer();

// 'foo()'는 프라미스-인식형 함수다.
foo(42).then(
  function fulfilled() {
    return p;
  },
  function rejected(err) {
    // 'foo()' 에러 처리
  }
);
```

p를 생성할 때 버림 상태를 사용/감지하려면 잠시 대기해야 하므로 defer()를 호출하는 데, 이렇게 하면 전역 범위로 알림이 발생하지 않음  
defer()는 계속 연쇄할 목적으로 같은 프라미스를 단순 반환함

foo()가 반환한 프라미스에는 곧바로 에러 처리기가 달리므로 알림 기능은 암시적으로 배제되고 전역 알림 또한 일어나지 않음

반면 then()이 반환한 프라미스엔 defer()나 에러 처리기 같은 것이 달려있지 않아 프라미스가 버림되면 잡히지 않은 에러 형태로 개발자 콘솔창에 나타나게 됨

이러한 설계를 '성공의 구덩이'라 함

이 접근 방식이 유일하게 위험한 경우는, 프라미스를 defer() 했으나 실제로 버림을 감지/처리하지 못했을 때임

## 9.6 프라미스 패턴

프라미스 연쇄의 시퀀스 패턴 외에도 프라미스에 기반을 두고 좀 더 추상화한 형태로 구축 가능한 비동기 패턴의 변형이 많이 존재

그중 두 패턴은 ES6 Promise에 바로 구현되어 있으므로 무료이고 다른 패턴 조합에 필요한 블록으로 사용 가능

### 9.6.1 Promise.all([])

비동기 시퀀스는 주어진 시점에 단 한 개의 비동기 작업만 가능  
2개 이상의 단계가 동시에 움직일 수는 없을까?

복수의 병렬/동시 작업이 끝날 때까지 진행하지 않고 대기하는 관문이라는 장치가 존재  
어느 쪽이 먼저 끝나든지 모든 작업이 다 끝나야 게이트가 열리고 다음으로 넘어감

이러한 패턴을 프라미스 API는 all([])에 담았음

Promise.all([])는 보통 프라미스 인스턴스들이 담긴 배열 하나를 인자로 받고 호출 결과 반환된 프라미스는 이룸 메시지를 수신  
이 메시지는 배열에 나열한 순서대로 프라미스들을 통과하면서 얻어짐 이룸 메시지의 배열

**_엄밀히 말하면 Promise.all([])에 전달하는 배열은 프라미스, 데너블 또는 즉시값 모두 가능하다. 배열값들은 하나씩 Promise.resolve()를 통과하면서 진짜 프라미스임을 보장하고 즉시값은 해당 값을 지닌 프라미스로 정규화된다. 빈 배열을 넘기면 메인 프라미스는 바로 이루어진다._**

Promise.all([])이 반환한 메인 프라미스는 자신의 하위 프라미스들이 모두 이루어져야 이루어질 수 있음  
단 한 개의 프라미스라도 버려지면 Promise.all([]) 프라미스 역시 곧바로 버려지며 다른 프라미스 결과도 덩달아 무효가 됨

프라미스마다 항상 버림/에러 처리기를 붙여넣도록 습관화하자

### 9.6.2 Promise.race([])

Promise.all([])은 여러 프라미스를 동시에 편성하여 모두 이루어진다는 전제로 작동하는 데, 최초의 프라미스만 인정하고 나머지는 무시해야 할 때도 있음

이른바 걸쇠라는 패턴으로, 프라미스에서는 경합이라고 함

Promise.race([]) 역시 하나 이상의 프라미스, 데너블, 즉시값이 포함된 배열 인자 1개를 받음  
하지만 즉시값은 결승선에서 출발하는 것이나 다름 없어 사실상 즉시값과의 경합은 아무런 의미가 없음

Promise.all([])처럼 Promise.race([]) 역시 하나라도 이루어진 프라미스가 있을 경우에 이루어지고 하나라도 버려지는 프라미스가 있으면 버려짐

##### 타임아웃 경합

Promise.race([])를 이용하면 프라미스 타임아웃 패턴을 구현할 수 있음

##### 결론

폐기/무시된 프라미스는 어떻게 되는 걸까?  
프라미스는 취소가 안 되고 외부적인 불변성에 관한 믿음을 무너뜨리면 안 되기에 그냥 조용히 묻혀짐

### 9.6.3 all([])/race([])의 변형

ES6 프라미스 내장된 Promise.all([]), Promise.race([])을 변형한 패턴 중에 자주 쓰이는 것들이 있음

- none([])
  all([])과 비슷하지만 이룸/버림이 정반대  
  따라서 모든 프라미스는 버려져야 하며, 버림이 이룸값이 되고 이룸이 버림값이 됨
- any([])
  all([])과 유사하나 버림은 모두 무시하며, 하나만 이루어지면 됨
- first([])
  any([])의 경합과 비슷함  
  일단 최초로 프라미스가 이루어지고 난 이후엔 다른 이룸/버림은 간단히 무시
- last([])
  first([])와 거의 같고 최후의 이룸 프라미스 하나만 승자가 된다는 것만 다름

### 9.6.4 동시 순회

프라미스 리스트를 쭉 순회하며 각각에 대해 어떤 처리를 하고 싶은 경우가 있음  
프라미스별로 처리할 작업이 근본적으로 동기적이라면 forEach()와 같은 함수만 있어도 충분

처리 작업이 비동기적이거나 동시 실행될 수 있다면 많은 라이브러리에서 제공하는 비동기 버전의 유틸리티 사용
