# Chapter 8. 콜백

콜백은 자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자, 사실상 자바스크립트 언어에서 가장 기본적인 비동기 패턴

## 8.1 연속성

콜백 함수는 프로그램의 연속성을 감싼/캡슐화한 장치

## 8.2 두뇌는 순차적이다

### 8.2.1 실행 vs 계획

비동기 코드 작성이 어려운 이유는 인간이 비동기 흐름을 생각하고 떠올리는 일 자체가 부자연스럽기 때문

인간은 단계별로 끊어 생각하는 경향이 있는데, 우리 손에 들려진 도구는 동기 -> 비동기로 전환된 이후론 단계별로 나타내기가 쉽지 않음

그래서 콜백으로 비동기 자바스크립트 코드를 정확하게 작성하고 추론하기란 상당히 어려움

### 8.2.2 중첩/연쇄된 콜백

콜백 지옥은 중첩/들여쓰기와는 무관하고 그보다 훨씬 심각한 문제를 야기

중첩/연쇄된 콜백과 같은 식의 선형적인 코드 추론에는 몇 가지 문제가 존재

첫째, 단순히 순차 실행될 경우는 많은 경우의 수 중 하나에 불과함  
실제 비동기 자바스크립트 프로그램에는 갖가지 잡음이 섞임  
콜백으로 가득한 코드의 비동기 흐름을 이해하는 일이 아주 불가능하진 않지만 많은 연습/훈련을 반복해도 자연스럽고 쉽게 이해할 만한 일은 아님

```javascript
doA(function () {
  doB();

  doC(function () {
    doD();
  });

  doE();
});

doF();
```

위 코드의 실행 순서는 다음과 같음

- doA()
- doF()
- doB()
- doC()
- doE()
- doD()

콜백의 첫 번째 단점은 사람의 두뇌가 순차적으로 중단을 일으키며 계획하는 방식이 콜백 지향의 비동기 코드와 잘 맞지 않는다는 것

## 8.3 믿음성 문제

순차적인 두뇌 계획과 콜백식 비동기 자바스크립트 코드 사이의 부조화는 콜백 문제점의 일부에 불과

```javascript
// A
ajax("..", function(..) {
    //  C
});
// B
```

A와 B는 자바스크립트 메인 프로그램의 제어를 직접 받으며 '지금' 실행되지만 //C는 다른 프로그램의 제어하에 '나중'에 실행됨

하지만 문제가 불거지는 주기가 길다고 하여 제어권 교환이 별일이 아니라고 지레짐작해선 안 됨  
사실, 제어권 교환이야말로 콜백 중심적 설계 방식의 가장 큰 문제점  
ajax()는 개발자가 작성하는 또는 개발자가 직접 제어할 수 있는 함수가 아니라 서드 파티가 제공한 유틸리티인 경우가 대부분

내가 작성하는 프로그램인데도 실행 흐름은 서드 파티에 의존해야 하는 이런 상황을 제어의 역전이라고 함

### 8.3.1 다섯 마리 콜백 이야기

p. 217 참고

### 8.3.2 남의 코드뿐만 아니라

p. 218 참고

## 8.4 콜백을 구하라

믿음성 문제를 일부라도 해결하기 위해 기존 디자인을 변형한 콜백 체계가 있음

예를 들어, 더욱 우아하게 에러를 처리하려고 분할 콜백 기능을 제공하는 API가 있음

```javascript
function success(data) {
  console.log(data);
}

function failure(err) {
  console.error(err);
}

ajax("http://some.url.1", sucess, failure);
```

**_분할 콜백 디자인은 ES6 프라미스 API가 사용하는 패턴이다._**

'에러 우선 스타일'이라는 콜백 패턴 또한 많이 사용  
단일 콜백 함수는 에러 객체를 첫 번째 인자로 받음  
성공 시 이 인자는 빈/falsy 객체로 채워지지만, 실패 시 truthy 또는 에러 객체로 세팅됨

```javascript
function response(err, data) {
  // 에러인가?
  if (err) {
    console.error(err);
  }
  // 아니면 성공한 것으로 본다.
  else {
    console.log(data);
  }
}

ajax("http://some.url.1", resopnse);
```

믿음성 문제가 해결된 것처럼 보이지만 사실 그렇지 않음  
원하지 않은 반복적인 호출을 방지하거나 걸러내는 콜백 기능이 전혀 없음  
더구나 이제는 성공/에러 신호를 동시에 받거나 아예 전혀 못 받을 수 있으므로 상황별로 코딩해야 하는 부담까지 가증

또한, 표준적인 패턴의 모습을 띠고 있음에도 재사용 불가능한, 장황한 관용 코드라서 실제로 애플리케이션을 개발할 때 매 콜백마다 타이핑해야 함

콜백을 한 번도 호출하지 않는 경우가 중요하다면 이벤트를 취소하는 타임아웃을 걸어놓아야 함

너무 일찍 콜백을 호출하는 것도 문제  
애플리케이션 관점에서 보면 실제로 어떤 중요한 작업을 마치기 전에 콜백을 부른 것

## 8.5 정리하기

콜백은 자바스크립트에서 비동기성을 표현하는 기본 단위  
그러나 자바스크립트와 더불어 점점 진화하는 비동기 프로그래밍 환경에서 콜백만으로는 충분치 않음

첫째, 사람의 두뇌는 순차적, 중단적, 단일-스레드 방식으로 계획하는 데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로 구현된 코드를 제대로 이해하기가 매우 어려움

둘째, 콜백은 프로그램을 진행하기 위해 제어를 역전, 즉 제어권을 다른 파트에 암시적으로 넘겨줘야 함  
이렇게 제어권이 넘어가면서 예상보다 더 자주 콜백을 호출하는 등 여러 가지 믿음성 문제에 봉착

믿음성 문제를 해결하고자 임시 로직을 짜 넣으면 생각만큼 구현하기 쉽지 않은 데다 거칠고 유지 보수가 어려운 코드로 변질됨

관용 코드를 여기저기 흩뿌리지 않고도 생성한 콜백들을 재사용할 수 있는, 그런 일반적인 해결 방안이 강구되어야 믿음성 문제를 해결할 수 있음
