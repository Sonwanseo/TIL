# Chapter 7. 비동기성: 지금과 나중

프로그램에서 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 비동기 프로그램의 핵심

요즘 자바스크립트는 일급 프로그래밍 언어로서의 요건을 충족하기 위해 응용 범위와 복잡도가 날로 증가하고 있으며, 이에 따라 비동기 요소를 관리해야 하는 부담과 고통 역시 증가중

## 7.1 프로그램 덩이

자바스크립트 프로그램은 .js 파일 하나로도 작성할 수 있지만 보통은 여러 개의 덩이, 곧 '지금' 실해 중인 프로그램 덩이 하나 + '나중'에 실행할 프로그램 덩이들로 구성됨  
가장 일반적인 프로그램 덩이 단위는 함수

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수
var data = ajax("http://some.url.1");

console.log(data);
// AJAX 결과는 보통 이렇게 'data'에 담지 못함
```

표준 AJAX 요청은 동기적으로 작동하지 않아 ajax() 함수 결괏값을 data 변수에 할당할 수 없음

AJAX는 비동기적으로 '지금' 요청하고 '나중'에 결과를 받음

'지금'부터 '나중'까지 '기다리는' 가장 간단한 방법은 '콜백 함수'를 사용하는 것

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data);
});
```

**_동기적인 AJAX 요청도 기술적으로는 가능하나 브라우저 UI를 얼어붙게 할 뿐 아니라 사용자와의 상호 작용이 완전히 마비될 수 있다._**

콜백 문제를 피하려고 'setTimeout'과 같은 함수를 이용하여 중단적/동기적 AJAX를 사용하는 행위는 절대 금지

코드 조각을 function으로 감싸놓고 이벤트에 반응하여 움직이게 하려면 '나중'덩이를 코딩하여 프로그램에 '비동기성'을 부여하면 됨

### 7.1.1 비동기 콘솔

Console.\* 메서드는 그 작동 방법이나 요건이 명세에 따로 정해져 있지 않지만 '호스팅 환경'에 추가된 기능

따라서 브라우저와 자바스크립트 실행 환경에 따라 작동 방식이 다르고 종종 혼동을 유발하기도 함

특히 cnosole.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있음  
많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문

I/O 지연이 언제 발생하여 엉뚱한 결과가 빚어질지는 상황에 따라 다르므로 정확히 예측하기 어려움  
하지만 console.log()문 이후 변경된 객체의 프로퍼티 값이 콘솔에 표시되는 문제로 디버깅할 땐 이러한 I/O 비동기성이 원인일 수 있다는 점을 염두

**_어쩌다 이렇게 흔치 않은 상황에 부닥칠 경우에는 무조건 콘솔창 결과에 의존하지 말고 자바스크립트 디버거의 중단점을 잘 활용하는 게 최선이다. 객체를 JSON.stringify() 등의 함수로 문자열 직렬화하여 '스냅샷'을 강제로 떠보는 것이 차선책이라고 할 수 있다._**

## 7.2 이벤트 루프

실제로 자바스크립트에 비동기란 개념이 있었던 적은 단 한번도 없었음

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 실행할 뿐임

자바스크립트 엔진은 혼자서는 안 되고 반드시 호스팅에서 실행됨  
지난 수년 동안 자바스크립트는 브라우저를 벗어나 다른 환경으로 그 영역을 확장해왔음

그러나 환경은 달라도 '스레드'는 공통  
여러 프로그램 덩이를 시간에 따라 매 순간 한 번씩 엔진을 실행시키는 '이벤트 루프'라는 장치

다시 말해, 자바스크립트 엔진은 시간이란 관념 따위는 없었고 임의의 자바스크립트 코드 조각을 시시각각 주는 대로 받아 처리하는 실행기일 뿐임

## 7.3 병렬 스레딩

'비동기'와 '병렬'은 섞어 쓰는 경우가 많지만 그 의미는 완전히 다름  
비동기는 '지금'과 '나중' 사이의 간극에 관한 용어고 병렬은 동시에 일어나는 일들과 연관됨

'프로세스'와 '스레드'는 가장 많이 쓰는 병렬 컴퓨팅 도구로, 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유함

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없음  
병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어남

```javascript
function later() {
  answer = answer * 2;
  console.log("인생의 의미: ", answer);
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행 중인 스레드 입장에선 실제로 여러 상이한 저수준의 작업들이 일어날 수 있음

단일-스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없음  
하지만 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템에선 예상치 못했던 일들이 일어날 수 잇음

```javascript
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

자바스크립트는 단일-스레드로 작동하니까 foo() -> bar() 순서로 실행하면 결괏값은 42지만 반대로 bar() -> foo() 순서면 41이 됨

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡함

이런 요소들이 스레드 프로그래밍을 어렵게 함  
인터럽션/인터리빙 같은 요소가 발생하지 않도록 조치하지 않으면 결괏값이 제멋대로로 출력됨

자바스크립트는 절대로 스레드 간에 데이터를 공유하는 법이 없으므로 비결정성의 수준은 문제가 되지 않음  
하지만 그렇다고 자바스크립트 프로그램이 항상 결정적이지도 않음

### 7.3.1 완전-실행

자바스크립트의 작동 모드는 단일-스레드이므로 foo() 내부의 코드는 원자적임  
즉, 일단 foo()가 실행되면 이 함수 전체 코드가 실행되고 나서야 bar() 함수로 옮아간다는 뜻  
이를 완전-실행이라 함

```javascript
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

foo()와 bar()는 상대의 실행을 방해할 수 없으므로 이 프로그램의 결괏값은 먼저 실행되는 함수가 좌우함  
만약 문 단위로도 스레딩이 일어나면 문별 인터리빙이 발생하여 경우의 수는 기하급수적으로 증가함

똑같은 코드인데 실행되는 함수의 순서에 따라 결괏값은 두 가지이므로 이 프로그램은 비결정적임  
그러나 여기서 비결정성은 함수의 순서에 따른 것이지, 스레드처럼 문의 순서 수준까지는 아님  
즉, 스레드보다는 결정적이라고 할 수 있음

자바스크립트에서는 함수 순서에 다른 비결정성을 흔히 경합 조건이라 표현함

## 7.4 동시성

사용자가 스크롤바를 아래로 내리면 계속 갱신된 상태 리스트가 화면에 표시되는 웹 페이지를 만들고자 할 때,  
이런 기능은 2개의 분리된 프로세스를 동시에 실행할 수 있어야 제대로 기능을 구현할 수 있음

**_여기서의 프롯느는 컴퓨터 과학 교과서에 나오는 운영 체제 수준의 프로세스가 아니다. 여기서 말하는 프로세스는 논리적으로 연결된 순차적인 일련의 작업을 나타내는 가상 프로세스 또는 작업을 의미한다._**

첫 번째 프로세스는 사용자가 페이지를 스크롤바로 내리는 순간 발생하는 onscroll 이벤트에 반응함  
두 번째 프로세스는 AJAX 응답을 받음

동시성은 복수의 프로세스가 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계 X  
동시성은 처리 수준 병행성과 상반되는 개념의 프로세스 수준의 병행성이라 할 수 있음

**_동시성에는 이러한 프로세스들이 상호 작용한다는 개념도 포함되어 있음_**

onscroll 이벤트와 AJAX 응답 이벤트는 동시에 발생할 수 있음

하지만 이벤트 루프 개념을 다시 곱씹어보면 자바스크립트는 한 번에 하나의 이벤트만 처리하므로 둘 중 어느 한쪽이 먼저 실행되고 정확히 같은 시각에 실행되는 일은 있을 수 없음

프로세스 1과 프로세스 2는 동시에 실행되지만 이들을 구성하는 이벤트들은 이벤트 루프 큐에서 차례대로 실행됨

단일-스레드 이벤트 루프는 동시성을 나타내는 하나의 표현 방식

### 7.4.1 비상호 작용

어떤 프로그램 내에서 복수의 프로세스가 단계/이벤트를 동시에 인터리빙 할 때 이들 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호 작용은 의미가 없음  
프로세스 간 상호 작용이 일어나지 않는다면 비결정성은 완벽하게 수용 가능

```javascript
var res = {};

function foo(results) {
  res.foo = results;
}

function bar(results) {
  res.bar = results;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

2개의 동시 프로세스 foo()와 bar() 중 누가 먼저 실행될지 알 수 없지만 적어도 서로에게 아무런 영향을 끼치지 않고 개별 작동하니 실행 순서는 문제 삼을 필요가 없음

### 7.4.2 상호 작용

동시 프로세스들은 필요할 때 스코프나 DOM을 통해 간접적으로 상호 작용함

```javascript
var res = [];

function response(data) {
  res.push(data);
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

두 동시 프로세스 모두 AJAX 응답 처리를 하는 response() 함수를 호출하는 터라 선발 순으로 처리됨

**_이런 상황에서 섣부른 가정을 하는 사람들이 많은데 유의해야 한다. 보통 개발자는 처리하는 작업의 성격을 보고 "http://some.url.2"의 응답이 "http://some.url.1"보다 항상 느릴 거라는 식의 확신한다. 하지만 요청 서버가 동일하고 이 서버가 특정 순서로 응답하도록 고정을 해놓아도 브라우저에 정말 어떤 순서로 응답이 도착할지는 아무도 장담할 수 없다._**

따라서 경합 조건을 해결하려면 상호 작용의 순서를 잘 조정해야 함

```javascript
var res = [];

function response(data) {
  if (data.url === "http://some.url.1") {
    res[0] = data;
  } else if (data.url === "http://some.url.2") {
    res[1] = data;
  }
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

이제 어느 쪽 AJAX 응답이 먼저 오더라도 data.url을 보고 res 배열의 어느 슬롯에 응답 데이터를 저장할 지 결정할 수 있음

한꺼번에 여러 함수를 호출하는 형태로 공유 DOM을 통해 상호 작용하는 경우도 마찬가지

### 7.4.3 협동

'협동적 동시성' 역시 동시성을 조정하는 다른 방안  
협동적 동시성은 실행 시간이 오래 걸리는 프로세스를 여러 단계/배치로 쪼개어 다른 동시 프로세스가 각자 작업을 이벤트 루프 큐에 인터리빙 하도록 하는게 목표

```javascript
var res = [];

// AJAX 호출 결과 'response()'는 배열을 받는다.
function response(data) {
  // 기존 'res' 배열에 추가한다.
  res = res.concat(
    // 배열의 원소를 하나씩 변환한다.
    // 원래 값을 2배로 늘린다.
    data.map(function (val) {
      return val * 2;
    })
  );
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

처음 "http://some.url.1" 호출 결과가 넘어오면 전체 리스트는 바로 res에 매핑됨

이 프로세스 실행 중에 페이지는 그대로 멈춰버림

따라서 이벤트 루프 큐를 독점하지 않는, 좀 더 친화적이고 협동적인 동시 시스템이 되려면 각 결과를 비동기 배치로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행되게끔 해야 함

setTimeout(..., 0)은 비동기 스케줄링 꼼수 중 하나로, "이 함수를 현재 이벤트 루프 큐의 맨 뒤에 붙여주시오"라는 말

**_setTimeout(..., 0)은 엄밀히 말해 원소를 이벤트 루프 큐에 곧바로 삽입하는 게 아니라 타이머가 다음 기회에 이벤트를 삽입한다. 예컨대, 연속 두 번 setTimeout(..., 0)을 호출해도 그 순서대로 처리되리란 보장은 없다. 따라서 이벤트 순서를 예측할 수 없는 타이머 표류 등의 다양한 상황이 연출될 수 있다. 노드JS의 process.nextTick()도 사용은 편하지만 모든 환경에서 비동기 이벤트 순서를 고정할 직접적인 방법은 없다._**

## 7.5 잡

'잡 큐'는 ES6부터 이벤트 루프 큐에 새롭게 도입된 개념임  
주로 프로미스의 비동기 작동에서 가장 많이 보게 될 것임

잡 큐는 이벤트 루프 큐에서 '매 틱의 끝자락에 매달려 있는 큐'라고 생각하면 가장 알기 쉬움  
이벤트 루프 틱 도중 발생 가능한, 비동기 특성이 내재된 액션으로 인해 전혀 새로운 이벤트가 이벤트 루프 큐에 추가되는 게 아니라 현재 틱의 잡 큐 끝 부분에 원소가 추가됨

잡은 같은 큐 끝에 더 많은 잡을 추가할 수 있는 구조이기 때문에 이론적으로는 '잡 루프'가 무한 반복되면서 프로그램이 다음 이벤트 루프 틱으로 이동할 기력을 상실할 수도 있음  
개념적으로는 프로그램에서 실행 시간이 긴 코드 또는 무한 루프를 표현한 것과 비슷

잡은 기본적으로 setTimeout(..., 0) 같은 꼼수와 의도는 비슷하지만 처리 순서가 더 잘 정의되어 있고 순서가 확실히 보장되는 방향으로 구현되어 있음

## 7.6 문 순서

자바스크립트 엔진은 반드시 프로그램에 표현된 문의 순서대로 실행하지 않음

```javascript
var a, b;

a = 10;
b = 30;

a = a + 1;
b = b + 1;

console.log(a + b); // 42
```

이 코드는 비동기적인 요소가 없어서 당연히 위 -> 아래 방향으로 한 줄씩 실행될 것만 같음

그러나 자바스크립트 엔진은 이 코드를 컴파일한 뒤, 문 순서를 재정렬하면서 실행 시간을 줄일 여지는 없는지 확인함

가령, 엔진은 이렇게 실행하면 더 빠르다고 판단할 수 있음

```javascript
var a, b;

a = 10;
a++;

b = 30;
b++;

console.log(a + b); // 42
```

어떤 경우라도 자바스크립트 엔진은 컴파일 과정에서 최종 결과가 뒤바뀌지 않도록 안전하게 최적화함

그러나 안전하지 않아 최적화하면 안 되는 경우도 존재

부수 효과가 있는 함수 호출, ES6 프록시 객체 등 컴파일러의 순서 조정으로 인해 현저한 부수 효과가 발생할 수 있음

## 7.7 정리하기

자바스크립트 프로그램은 언제나 2개 이상의 덩이로 쪼개지며 이벤트 응답으로 첫 번째 덩이는 '지금', 다음 덩이는 '나중'에 실행됨  
한 덩이 씩 실행되어도 모든 덩이가 프로그램의 스코프/상태에 똑같이 접근할 수 있으므로 상태 변화는 차례대로 반영됨

실행할 이벤트가 있으면 이벤트 루프는 큐를 다 비울 때가지 실행  
이벤트 루프를 한 차례 순회하는 것을 틱이라 함

언제나 한 번에 정확히 한 개의 이벤트만 큐에서 꺼내 처리함  
이벤트 실행 도중, 하나 또는 그 이상의 후속 이벤트를 직/간접적으로 발생시킬 수 있음

동시성은 복수의 이벤트들이 연쇄적으로 시간에 따라 인터리빙 되면서 고수준의 관점에서 볼 때 꼭 동시에 실행되는 것처럼 보임

동시 프로세스들은 어떤 형태로든 서로 영향을 미치는 작업을 조정하여 실행 순서를 보장하거나 경합 조건을 예방하는 등의 조치를 해야 함  
이 프로세스 자체를 더 작은 덩이로 잘게 나누어 다른 프로세스에 인터리빙 되는 형태의 협동 또한 가능
