# Chapter 7. 비동기성: 지금과 나중

프로그램에서 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 비동기 프로그램의 핵심

요즘 자바스크립트는 일급 프로그래밍 언어로서의 요건을 충족하기 위해 응용 범위와 복잡도가 날로 증가하고 있으며, 이에 따라 비동기 요소를 관리해야 하는 부담과 고통 역시 증가중

## 7.1 프로그램 덩이

자바스크립트 프로그램은 .js 파일 하나로도 작성할 수 있지만 보통은 여러 개의 덩이, 곧 '지금' 실해 중인 프로그램 덩이 하나 + '나중'에 실행할 프로그램 덩이들로 구성됨  
가장 일반적인 프로그램 덩이 단위는 함수

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수
var data = ajax("http://some.url.1");

console.log(data);
// AJAX 결과는 보통 이렇게 'data'에 담지 못함
```

표준 AJAX 요청은 동기적으로 작동하지 않아 ajax() 함수 결괏값을 data 변수에 할당할 수 없음

AJAX는 비동기적으로 '지금' 요청하고 '나중'에 결과를 받음

'지금'부터 '나중'까지 '기다리는' 가장 간단한 방법은 '콜백 함수'를 사용하는 것

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data);
});
```

**_동기적인 AJAX 요청도 기술적으로는 가능하나 브라우저 UI를 얼어붙게 할 뿐 아니라 사용자와의 상호 작용이 완전히 마비될 수 있다._**

콜백 문제를 피하려고 'setTimeout'과 같은 함수를 이용하여 중단적/동기적 AJAX를 사용하는 행위는 절대 금지

코드 조각을 function으로 감싸놓고 이벤트에 반응하여 움직이게 하려면 '나중'덩이를 코딩하여 프로그램에 '비동기성'을 부여하면 됨

### 7.1.1 비동기 콘솔

Console.\* 메서드는 그 작동 방법이나 요건이 명세에 따로 정해져 있지 않지만 '호스팅 환경'에 추가된 기능

따라서 브라우저와 자바스크립트 실행 환경에 따라 작동 방식이 다르고 종종 혼동을 유발하기도 함

특히 cnosole.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있음  
많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문

I/O 지연이 언제 발생하여 엉뚱한 결과가 빚어질지는 상황에 따라 다르므로 정확히 예측하기 어려움  
하지만 console.log()문 이후 변경된 객체의 프로퍼티 값이 콘솔에 표시되는 문제로 디버깅할 땐 이러한 I/O 비동기성이 원인일 수 있다는 점을 염두

**_어쩌다 이렇게 흔치 않은 상황에 부닥칠 경우에는 무조건 콘솔창 결과에 의존하지 말고 자바스크립트 디버거의 중단점을 잘 활용하는 게 최선이다. 객체를 JSON.stringify() 등의 함수로 문자열 직렬화하여 '스냅샷'을 강제로 떠보는 것이 차선책이라고 할 수 있다._**

## 7.2 이벤트 루프

실제로 자바스크립트에 비동기란 개념이 있었던 적은 단 한번도 없었음

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 실행할 뿐임

자바스크립트 엔진은 혼자서는 안 되고 반드시 호스팅에서 실행됨  
지난 수년 동안 자바스크립트는 브라우저를 벗어나 다른 환경으로 그 영역을 확장해왔음

그러나 환경은 달라도 '스레드'는 공통  
여러 프로그램 덩이를 시간에 따라 매 순간 한 번씩 엔진을 실행시키는 '이벤트 루프'라는 장치

다시 말해, 자바스크립트 엔진은 시간이란 관념 따위는 없었고 임의의 자바스크립트 코드 조각을 시시각각 주는 대로 받아 처리하는 실행기일 뿐임

## 7.3 병렬 스레딩

'비동기'와 '병렬'은 섞어 쓰는 경우가 많지만 그 의미는 완전히 다름  
비동기는 '지금'과 '나중' 사이의 간극에 관한 용어고 병렬은 동시에 일어나는 일들과 연관됨

'프로세스'와 '스레드'는 가장 많이 쓰는 병렬 컴퓨팅 도구로, 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유함

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없음  
병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어남

```javascript
function later() {
  answer = answer * 2;
  console.log("인생의 의미: ", answer);
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행 중인 스레드 입장에선 실제로 여러 상이한 저수준의 작업들이 일어날 수 있음

단일-스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없음  
하지만 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템에선 예상치 못했던 일들이 일어날 수 잇음

```javascript
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

자바스크립트는 단일-스레드로 작동하니까 foo() -> bar() 순서로 실행하면 결괏값은 42지만 반대로 bar() -> foo() 순서면 41이 됨

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡함

이런 요소들이 스레드 프로그래밍을 어렵게 함  
인터럽션/인터리빙 같은 요소가 발생하지 않도록 조치하지 않으면 결괏값이 제멋대로로 출력됨

자바스크립트는 절대로 스레드 간에 데이터를 공유하는 법이 없으므로 비결정성의 수준은 문제가 되지 않음  
하지만 그렇다고 자바스크립트 프로그램이 항상 결정적이지도 않음

### 7.3.1 완전-실행

자바스크립트의 작동 모드는 단일-스레드이므로 foo() 내부의 코드는 원자적임  
즉, 일단 foo()가 실행되면 이 함수 전체 코드가 실행되고 나서야 bar() 함수로 옮아간다는 뜻  
이를 완전-실행이라 함

```javascript
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

foo()와 bar()는 상대의 실행을 방해할 수 없으므로 이 프로그램의 결괏값은 먼저 실행되는 함수가 좌우함  
만약 문 단위로도 스레딩이 일어나면 문별 인터리빙이 발생하여 경우의 수는 기하급수적으로 증가함

똑같은 코드인데 실행되는 함수의 순서에 따라 결괏값은 두 가지이므로 이 프로그램은 비결정적임  
그러나 여기서 비결정성은 함수의 순서에 따른 것이지, 스레드처럼 문의 순서 수준까지는 아님  
즉, 스레드보다는 결정적이라고 할 수 있음

자바스크립트에서는 함수 순서에 다른 비결정성을 흔히 경합 조건이라 표현함
