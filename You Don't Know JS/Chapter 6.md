# Chapter 6. 작동 위임

5장 프로토타입의 결론은 한 문장으로 요약하면 "[[Prototype]] 체계는 한 객체가 다른 객체를 참조하기 위한 내부 링크"

이러한 링크는 처음 참조하는 객체에 존재하지 않는 프로퍼티/메서드를 참조하려고 할 경우 활용됨  
엔진은 [[Prototype]] 링크를 따라가며 연결된 객체마다 프로퍼티/메서드가 있는지 조사  
발견되지 않으면 다음 [[Prototype]] 링크에 연결된 객체를 타고 이동하며 조사는 계속됨  
이렇게 죽 이어진 한 무더기의 객체 간 연결 고리가 바로 '프로토타입 연쇄'

## 6.1 위임 지향 디자인으로 가는 길

[[Prototype]]의 사용 방법을 가장 쉽게 이해하려면 먼저 [[Prototype]]이 클래스와는 근본부터 다른 디자인 패턴이라는 사실을 인지해야 함

### 6.1.1 클래스 이론

클래스 기반의 디자인 설계 과정

1. 태스크의 공통 작동 정의
2. 태스크의 자식 클래스 정의
3. 이들에 특화된 작동은 자식 클래스에 각각 추가

클래스 디자인 패턴에서는 상속의 진가를 발휘하기 위해 될 수 있으면 메서드를 오버라이드할 것을 권장  
작동 추가뿐 아니라 때에 따라서 오버라이드 이전 원본 메서드를 super 키워드로 호출할 수 있게 지원  
공통 요소는 추상화하여 부모 클래스의 일반 메서드로 구현하고 자식 클래스는 이를 더 세분화하여 사용

```javascript
class Task {
  id;

  // 'Task()' 생성자
  Task(ID) { id = ID; }
  outputTask() { output(id); }
}

class XYZ inherits Task {
    label;

    // 'XYZ()' 생성자
    XYZ(ID, Label) { super(ID); label = Label; }
    outputTask() { super(); output(label); }
}

class ABC inherits Task {
    // ...
}
```

인스턴스가 생성되면 원하는 작동은 인스턴스에 모두 복사되어 옮겨진 상태이므로 일반적으로 오직 인스턴스와 상호 작용을 한 게 됨

### 6.1.2 위임 이론

똑같은 문제를 클래스 대신 작동 위임을 이용  
먼저 Task 객체를 정의하는데, 이 객체에는 다양한 태스크에서 사용할 유틸리티 메서드가 포함된 구체적인 작동이 기술됨  
태스크별 객체를 정의하여 고유한 데이터와 작동을 정의하고 Task 유틸리티 객체에 연결해 필요할 때 특정 태스크 객체가 Task에 작동을 위임하도록 작성

기본적으로 XYZ 태스크 하나를 실행하려면 2개의 형제, 동료 객체로부터 작동을 가져온다고 가정  
하지만 클래스 복사를 통해 이 둘을 조합하지 않아도 각자 별개의 객체로 분리된 상태에서 필요할 때마다 XYZ 객체가 Task 객체에 작동을 위임하는 구조

```javascript
Task = {
  setID: function (ID) {
    this.id = ID;
  },
  outputID: function () {
    console.log(this.id);
  },
};

// 'XYZ'가 'Task'에 위임한다.
XYZ = Object.create(Task);

XYZ.prepareTask = function (ID, Label) {
  this.setID(ID);
  this.label = Label;
};

XYZ.outputTaskDetails = function () {
  this.output(ID);
  console.log(this.label);
};

// ABC = Object.creaet(Task);
// ABC ... = ...
```

자바스크립트의 [[Prototype]] 체계는 객체를 다른 객체에 연결  
클래스 같은 추상화 체계는 없음

이러한 스타일 코드의 특징

1. 예제 코드에서 id와 label, 두 데이터 멤버는 XYZ의 직속 프로퍼티  
   일반적으로 [[Prototype]] 위임 시 상탯값은 위임하는 쪽에 두고 위임받는 쪽에 두지 않음

2. 클래스 디자인 패턴에서는 일부러 부모/자식 양쪽에 메서드 이름을 outputTask라고 똑같이 붙여 오버라이드(다형성)를 이용  
   작동 위임 패턴은 정반대  
   서로 다른 수준의 [[Prototype]] 연쇄에서 같은 명칭이 뒤섞이는 일은 피해야 함  
   같은 이름끼리 충돌하면 레퍼런스를 정확히 가려낼 수 없는 부자연스럽고 취약한 구문이 만들어지므로 작동 위임 패턴에서는 오버라이드하기 딱 좋은 일반적인 메서드 명칭보다는 각 객체의 작동 방식을 잘 설명하는 서술적인 명칭이 필요  
   이렇게 해야 메서드의 이름만 봐도 어떤 작동을 하는지 그 의미가 분명해지므로 코드의 가독성과 유지 보수성이 향상됨

3. this.setID(ID);는 일단 XYZ 객체 내부에서 setID()를 찾지만 XYZ에는 이 메서드가 존재하지 않으므로 [[Prototype]] 위임 링크가 체결된 Task로 이동하여 setID()를 발견  
   그리고 암시적으로 호출부에 따른 this 바인딩 규칙에 따라 Task에서 발견된 메서드지만 setID() 실행 시 this는 XYZ로 바인딩 됨  
   글다음 this.outputID()도 마찬가지  
   즉, XYZ가 Task에 작동을 위임하므로 Task가 가진 일반적인 유틸리티 메서드는 XYZ가 얼마든지 이용할 수 있는 셈

'작동 위임'이란 찾으려는 프로퍼티/메서드 레퍼런스가 객체에 없으면 다른 객체로 수색 작업을 위임하는 것을 의미  
작동 위임은 강력한 디자인 패턴으로, 부모/자식 클래스, 상속, 다형성 등의 사상과는 완전히 구별됨

**_위임은 상세한 내부 구현 용도로 적절하며 API 인터페이스에 직접 노출시키지는 않는다. 조금 전 예제도 API 사용자가 XYZ.setID()를 호출하게 할 필요는 없다. XYZ.prepareTask()가 Task.setID()에 위임한 내부 사정을 감추는 것이다._**

##### 상호 위임(허용되지 않음)

복수의 객체가 양방향으로 상호 위임을 하면 발생하는 사이클은 허용되지 않음  
즉, [B -> A]로 링크된 상태에서 [A -> B]로 링크하려고 시도하면 에러 발생
