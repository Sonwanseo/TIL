# Chapter 6. 작동 위임

5장 프로토타입의 결론은 한 문장으로 요약하면 "[[Prototype]] 체계는 한 객체가 다른 객체를 참조하기 위한 내부 링크"

이러한 링크는 처음 참조하는 객체에 존재하지 않는 프로퍼티/메서드를 참조하려고 할 경우 활용됨  
엔진은 [[Prototype]] 링크를 따라가며 연결된 객체마다 프로퍼티/메서드가 있는지 조사  
발견되지 않으면 다음 [[Prototype]] 링크에 연결된 객체를 타고 이동하며 조사는 계속됨  
이렇게 죽 이어진 한 무더기의 객체 간 연결 고리가 바로 '프로토타입 연쇄'

## 6.1 위임 지향 디자인으로 가는 길

[[Prototype]]의 사용 방법을 가장 쉽게 이해하려면 먼저 [[Prototype]]이 클래스와는 근본부터 다른 디자인 패턴이라는 사실을 인지해야 함

### 6.1.1 클래스 이론

클래스 기반의 디자인 설계 과정

1. 태스크의 공통 작동 정의
2. 태스크의 자식 클래스 정의
3. 이들에 특화된 작동은 자식 클래스에 각각 추가

클래스 디자인 패턴에서는 상속의 진가를 발휘하기 위해 될 수 있으면 메서드를 오버라이드할 것을 권장  
작동 추가뿐 아니라 때에 따라서 오버라이드 이전 원본 메서드를 super 키워드로 호출할 수 있게 지원  
공통 요소는 추상화하여 부모 클래스의 일반 메서드로 구현하고 자식 클래스는 이를 더 세분화하여 사용

```javascript
class Task {
  id;

  // 'Task()' 생성자
  Task(ID) { id = ID; }
  outputTask() { output(id); }
}

class XYZ inherits Task {
    label;

    // 'XYZ()' 생성자
    XYZ(ID, Label) { super(ID); label = Label; }
    outputTask() { super(); output(label); }
}

class ABC inherits Task {
    // ...
}
```

인스턴스가 생성되면 원하는 작동은 인스턴스에 모두 복사되어 옮겨진 상태이므로 일반적으로 오직 인스턴스와 상호 작용을 한 게 됨

### 6.1.2 위임 이론

똑같은 문제를 클래스 대신 작동 위임을 이용  
먼저 Task 객체를 정의하는데, 이 객체에는 다양한 태스크에서 사용할 유틸리티 메서드가 포함된 구체적인 작동이 기술됨  
태스크별 객체를 정의하여 고유한 데이터와 작동을 정의하고 Task 유틸리티 객체에 연결해 필요할 때 특정 태스크 객체가 Task에 작동을 위임하도록 작성

기본적으로 XYZ 태스크 하나를 실행하려면 2개의 형제, 동료 객체로부터 작동을 가져온다고 가정  
하지만 클래스 복사를 통해 이 둘을 조합하지 않아도 각자 별개의 객체로 분리된 상태에서 필요할 때마다 XYZ 객체가 Task 객체에 작동을 위임하는 구조

```javascript
Task = {
  setID: function (ID) {
    this.id = ID;
  },
  outputID: function () {
    console.log(this.id);
  },
};

// 'XYZ'가 'Task'에 위임한다.
XYZ = Object.create(Task);

XYZ.prepareTask = function (ID, Label) {
  this.setID(ID);
  this.label = Label;
};

XYZ.outputTaskDetails = function () {
  this.output(ID);
  console.log(this.label);
};

// ABC = Object.creaet(Task);
// ABC ... = ...
```

자바스크립트의 [[Prototype]] 체계는 객체를 다른 객체에 연결  
클래스 같은 추상화 체계는 없음

이러한 스타일 코드의 특징

1. 예제 코드에서 id와 label, 두 데이터 멤버는 XYZ의 직속 프로퍼티  
   일반적으로 [[Prototype]] 위임 시 상탯값은 위임하는 쪽에 두고 위임받는 쪽에 두지 않음

2. 클래스 디자인 패턴에서는 일부러 부모/자식 양쪽에 메서드 이름을 outputTask라고 똑같이 붙여 오버라이드(다형성)를 이용  
   작동 위임 패턴은 정반대  
   서로 다른 수준의 [[Prototype]] 연쇄에서 같은 명칭이 뒤섞이는 일은 피해야 함  
   같은 이름끼리 충돌하면 레퍼런스를 정확히 가려낼 수 없는 부자연스럽고 취약한 구문이 만들어지므로 작동 위임 패턴에서는 오버라이드하기 딱 좋은 일반적인 메서드 명칭보다는 각 객체의 작동 방식을 잘 설명하는 서술적인 명칭이 필요  
   이렇게 해야 메서드의 이름만 봐도 어떤 작동을 하는지 그 의미가 분명해지므로 코드의 가독성과 유지 보수성이 향상됨

3. this.setID(ID);는 일단 XYZ 객체 내부에서 setID()를 찾지만 XYZ에는 이 메서드가 존재하지 않으므로 [[Prototype]] 위임 링크가 체결된 Task로 이동하여 setID()를 발견  
   그리고 암시적으로 호출부에 따른 this 바인딩 규칙에 따라 Task에서 발견된 메서드지만 setID() 실행 시 this는 XYZ로 바인딩 됨  
   글다음 this.outputID()도 마찬가지  
   즉, XYZ가 Task에 작동을 위임하므로 Task가 가진 일반적인 유틸리티 메서드는 XYZ가 얼마든지 이용할 수 있는 셈

'작동 위임'이란 찾으려는 프로퍼티/메서드 레퍼런스가 객체에 없으면 다른 객체로 수색 작업을 위임하는 것을 의미  
작동 위임은 강력한 디자인 패턴으로, 부모/자식 클래스, 상속, 다형성 등의 사상과는 완전히 구별됨

**_위임은 상세한 내부 구현 용도로 적절하며 API 인터페이스에 직접 노출시키지는 않는다. 조금 전 예제도 API 사용자가 XYZ.setID()를 호출하게 할 필요는 없다. XYZ.prepareTask()가 Task.setID()에 위임한 내부 사정을 감추는 것이다._**

##### 상호 위임(허용되지 않음)

복수의 객체가 양방향으로 상호 위임을 하면 발생하는 사이클은 허용되지 않음  
즉, [B -> A]로 링크된 상태에서 [A -> B]로 링크하려고 시도하면 에러 발생

아무 데도 존재하지 않는 프로퍼티/메서드를 참조하려고 하면 분명 [[Prototype]] 순회 시 무한 루프에 빠지겠지만 모든 레퍼런스가 확실히 존재한다면 [B -> A]와 [A -> B] 양방향 위임은 가능  
즉, 한 객체를 다른 객체에 위임하는 형태로 다양하게 활용 가능

##### 디버깅

각각의 웹 브라우저 자바스크립트 코드를 해석하는 결과가 다름

```javascript
function Foo() {}
var a1 = new Foo();
a1;
```

크롬에서는 a1을 Foo {}로 평가하지만, 파이어폭스에서는 Object {}로 평가

크롬의 관점은 "{}는 Foo라고 명명된 함수가 생성된 빈 개체다"라는 것이고 파이어폭스는 "{}는 Object에 의해 일반적으로 생성된 빈 객체다"라고 바라봄

이 코드를 OLOO로 바꿔보자  
OLOO 스타일 코드에서 권장하는 대로 객체 생성 시 '생성자'를 쓰지 않으면 크롬이 내부적으로 '생성자명'을 추적하지 않는 객체가 생길 테고 그런 객체는 Object {}로 제대로 출력되어 'Object()에 의해 생성된 객체'임을 알 수 있음

OLOO와 작동 위임 패턴으로 코딩하면 누가 어떤 객체를 '생성했는지'는 그다지 중요 X

### 6.1.3 멘탈 모델 비교

OLOO 스타일로 코드를 짜면 잡다한 것들이 정리되고 단순해짐  
생성자, 프로토타입, new 호출을 하면서 클래스처럼 보이게 하려고 헷갈리기만 한 장치들을 쓰지 않고 그냥 객체를 서로 연결해줌

클래스 스타일 코드의 멘탈 모델은 반드시 세세하게 알고 있을 필요 없는, 지나치게 상세한 부분까지 표시되어 있어서 자칫 잘못 해석할 여지가 있고 관계도 매우 복잡하게 얽혀 있음  
그래도 시간을 들여 관계 화살표를 잘 따라가 보면 놀라울 정도로 정교한 자바스크립트 체계의 일관성을 엿볼 수 있음

어떤 자바스크립트 함수가 call(), apply(), bind() 메서드에 접근할 수 있는 건 함수 자신도 객체고 함수 객체 역시 Function.prototype에 [[Prototype]]이 연결되어 모든 함수 객체가 위임 가능한 기본 메서드가 있기에 가능

반면 OLOO 스타일 코드의 멘탈 모델은 다른 객체와의 연결에만 집중하면 되므로 고민할 요소가 현저히 줄어듬

최종 결과가 같다면 '클래스' 요소는 복잡하고 혼란스러움

## 6.2 클래스 vs 객체

### 6.2.1 위젯 클래스

OO 디자인 패턴에 따르면 부모 클래스에는 기본 render()만 선언해두고 자식 클래스가 이를 오버라이드하도록 유도  
기본 기능을 완전히 갈아치운다기보단 버튼에만 해당하는 작동을 덧붙여 기본 기능을 증강

##### ES6 class 간편 구문

상황에 따라 코드를 class로 구현하면 이전 코드보다 상당히 매끄럽게 바뀜

### 6.2.2 위젯 객체의 위임

디자인 패턴 관점에서 클래스 방식이 고집하는 같은 이름의 render() 메서드 따위는 공유할 필요가 없음  
대신, 각자 수행하는 임무를 더욱 구체적으로 드러낼 수 있는 다른 이름들을 메서드에 부여

클래스 생성자로는 생성과 초기화를 한 번에 해야 하지만 실제로는 OLOO 방식처럼 두 단계로 나누어 실행하면 더 유연해지는 경우가 많음  
예를 들어, 프로그램이 시작될 때 모든 인스턴스를 생성하여 어떤 풀에 담아두고 여기서 인스턴스를 뽑아 사용하는 시점에 어떤 설정을 초기화하고 싶을 때가 종종 존재

생성 및 초기화 과정을 굳이 한곳에 몰아넣고 실행하지 않아도 되니 OLOO는 관심사 분리의 원칙을 더 잘 반영한 패턴

## 6.3 더 간단한 디자인

겉으로 드러나는 코드가 더 간단해지는 장점 외에도 작동 위임 패턴은 실제로 더 간단한 코드 아키텍처를 가능케 함
163p 참조

### 6.3.1 탈클래스화

작동 위임 패턴에서는 억지로 부모/자식 관계를 맺을 필요가 없음

위임만으로도 강력한 체계이므로 필요한 기능 구현에 문제가 없음  
또 클래스 자체가 하나도 없으므로 클래스 인스턴스화 과정도 생략  
게다가 필요할 때 위임을 통해 두 객체가 서로 협조할 수 있는 형태이므로 구성 역시 없어도 됨

마지막으로 클래스 지향 디자인의 고질적인 다형성 문제도 해결됨

같은 기능을 훨씬 더 간단한 디자인으로 설계할 수 있다는 것이 OLOO 스타일 코드의 힘이자 작동 위임 디자인 패턴의 강력함

## 6.4 더 멋진 구문

ES6 class가 시선을 잡아끄는 매력 중 하나는 클래스 메서드를 짧은 구문으로 선언할 수 있다는 점

선언 시 function 키워드가 빠짐

ES6부터는 객체 리터럴에 단축 메서드 선언이 가능

그리고 ES6부턴 프로퍼티를 하나씩 할당할 때 객체 리터럴 없이 썼던 투박한 구문을 객체 리터럴로 나타낼 수 있고 객체 [[Prototype]]을 Object.setPrototypeOf()로 간단히 수정 가능

### 6.4.1 비어휘적 식별자

그러나 단축 메서드에도 미묘하지만 간과해성는 안 될 결점이 존재

```javascript
var Foo = {
  bar() {
    /* */
  },
  baz: function baz() {
    /* */
  },
};
```

일반 표현식으로 표현하면 다음과 같음

```javascript
var Foo = {
  bar: function () {
    /* */
  },
  baz: function baz() {
    /* */
  },
};
```

단축 메서드 bar()가 프로퍼티에 붙여진 '익명 함수 표현식'이 됨  
이는 함수 객체 자신에 이름 식별자가 없기 때문

익명 함수 표현식의 단점

1. 스택 추적을 통해 디버깅 하기가 곤란해짐
2. 재귀, 이벤트 바인딩 등에서 자기 참조가 어려워짐
3. 코드의 가독성 저하

1, 3번은 단축 메서드에는 해당하지 않음

비간편 구문에서는 대개 스택 추적 시 이름이 나오지 않는 익명 함수 표현식을 사용하지만 단축 메서드는 내부 프로퍼티 name에 해당 함수 객체를 정확히 지정하므로 스택 추적에 활용 가능

하지만 2번은 아쉽게도 단축 메서드의 단점  
자기 참조에 사용할 수 있는 어휘적 식별자 X

```javascript
var Foo = {
  bar: function (x) {
    if (x < 10) {
      return Foo.bar(x * 2);
    }
    return x;
  },
  baz: function baz(x) {
    if (x < 10) {
      return baz(x * 2);
    }
    return x;
  },
};
```

Foo.bar()처럼 수동으로 참조하는 방법도 있지만 여러 객체가 this 바인딩을 통해 위임을 공유하는 함수처럼 할 수 없는 경우가 꽤 존재  
자기 참조가 필요한 상황에 직면할 가능성이 있을 테니 함수 객체의 이름 식별자는 지정하는 게 좋음

## 6.5 인트로스펙션

타입 인트로스펙션은 인스턴스를 조사해 객체 유형을 거꾸로 유추하는 것  
클래스 인스턴스에서 타입 인트로스펙션은 주로 인스턴스가 생성된 소스 객체의 구조와 기능을 추론하는 용도로 사용됨

다음은 instanceof 연산자로 객체 a1의 기능을 추론하는 코드

```javascript
function Foo() {
  // ...
}
Foo.prototype.something = function () {
  // ...
};

var a1 = new Foo();

if (a1 instanceof Foo) {
  a1.something();
}
```

Foo.prototype은 a1의 [[Prototype]] 연쇄에 존재하므로 instanceof 연산자는 마치 a1이 Foo '클래스'의 인스턴스인 것 같은 결과를 출력

But, Foo는 일반 객체에 불과하며, Foo가 참조한 임의의 객체가 a1에 위임 연결됐을 뿐임  
instanceof가 a1과 Foo의 관계를 조사하는 듯 보이지만 실제로는 a1과 Foo.prototype 사이의 관계를 알려주는 일을 함

이렇게 instanceof에 의존하여 a1이 주어진 객체와 연결되는지를 인트로스펙션하는 건 의미 상 헷갈리기도 하고 간접적일 수밖에 없으므로 해당 객체를 참조하는 레퍼런스를 지닌 함수가 필요

'덕 타이핑'이라고 하여 많은 개발자가 instanceof보다 선호하는 또 다른 타입 인트로스펙션 방법도 존재

예를 들면, 위임 가능한 something() 함수를 가진 객체와 a1의 관계를 조사하는 대신 a1.something을 테스트해보고 통과하면 a1은 .something()을 호출할 자격이 있다고 간주하는 것

그러나 '덕 타이핑'은 기존 테스트 결과 이외에 객체의 다른 기능까지 확장하여 추정하는 경향이 있어 리스크가 더해짐

가장 유명한 '덕 타이핑'의 실례가 바로 ES6 프라미스  
여러 가지 이유에서 어떤 임의의 객체 레퍼런스가 프라미스인지를 판단해야 할 경우 해당 객체가 then() 함수를 가졌는지 조사하는 식으로 테스트함  
즉, 어떤 객체에 then() 메서드가 있으면 ES6 프라미스는 무조건 이 객체는 '데너블'하다고 단정짓고 모든 표준 프라미스 작동 로직을 갖추고 있을 거라 예상함

모든 객체가 [[Prototype]] 위임을 통해 연관된 OLOO 방식에서는 꽤 단순한 형태로 타입 인트로스펙션이 가능

저자의 개인적인 생각으로는 이러한 방식의 타입 인트로스펙션이 훨씬 덜 복잡하고 혼동의 여지가 없다고 본다고 함  
여기서도 다시 한 번 OLOO가 자바스크립트에서는 클래스 스타일보다 더 간단한 코딩 디자인 패턴임을 알 수 있음

## 6.6 정리하기

개발자 대부분은 클래스가 코드 체계를 잡는 유일무이한 방법이라고 당연시하는데, '작동 위임'이라는 강력한 디자인 패턴에 대해 학습함

작동 위임 패턴은 객체를 부모/자식 클래스 관계가 아닌 동등한 입장에서 서로 위임하는 형태로 연결되어 있음  
자바스크립트 [[Prototype]]은 태생적으로 작동 위임 체계임

객체만으로 구성된 코드를 구성한다먄 사용 구문도 단순해질뿐더러 실제로 코드 아키텍처 또한 더 간단하게 가져갈 수 잇음

OLOO는 클래스라는 추상화 장치 없이도 직접 객체를 생성 및 연계함  
OLOO는 [[Prototype]] 기반의 작동 위임을 자연스럽게 구현
