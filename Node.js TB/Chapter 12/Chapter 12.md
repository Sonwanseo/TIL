# Chapter 12. 실시간 경매 시스템 만들기

## 12.1 프로젝트 구조 갖추기

프로젝트는 새 모델, 즉 사용자 모델, 제품 모델, 경매 모델로 구성됩니다.

사용자 모델은 이메일(email), 닉네임(nick), 비밀번호(password), 보유 자금(money)으로 구성됩니다.

상품 모델을 상품명(name), 상품 사진(img), 시작 가격(price)으로 구성됩니다.

경메 모델은 입찰가(bid)와 입찰 시 메시지(msg)로 구성됩니다.
입찰 시 메시지는 null이어도 됩니다.

모델을 생성한 후에 모델을 데이터베이스 및 서버와 연결합니다.

sequelize db:create 명령어로 데이터베이스를 생성합니다.

사용자가 입찰을 여러 번 할 수 있으므로 사용자 모델과 경매 모델도 일대다 관계입니다.
한 상품에 여러 명이 입찰하므로 상품 모델과 경매 모델도 일대다 관계입니다.

사용자 모델과 상품 모델 간에는 일대다 관계가 두 번 적용됩니다.
사용자가 여러 상품을 등록할 수 있고, 사용자가 여러 상품을 낙찰받을 수도 있기 때문입니다.
두 관계를 구별하기 위해 as 속성에 owner, sold로 관계명을 적어주었습니다.
각각 ownerId, soldId 컬럼으로 상품 모델에 추가됩니다.

경매 시스템은 회원가입, 로그인, 경매상품 등록, 방 참여, 경매 진행으로 이루어져 있습니다.

상품을 업로드하는 페이지인 good.pug 파일에서는 이미지 업로드(#good-img)도 같이 해야 하므로 form 태그의 enctype이 multipart/form-data로, 폼데이터를 사용하도록 설정하였습니다.

router.use에서 res.locals.user = req.user;로 모든 pug 템플릿에 사용자 정보를 변수로 집어 넣었습니다.
이렇게 하면 res.render 메서드에 user: req.user를 하지 않아도 되므로 중복을 제거할 수 있습니다.

라우터는 GET /, GET /join, GET /good, POST /good으로 이루어져 있습니다.
GET /는 메인 화면을 렌더링합니다.
렌더링할 때 경매가 진행 중인 상품 목록도 같이 불러옵니다.
soldId가 낙찰자의 아이디이므로 낙찰자가 null이면 경매가 진행 중인 것입니다.
GET /join과 GET /good는 각각 회원가입 화면과 상품 등록 화면을 렌더링합니다.
POST /good 라우터는 업로드한 상품을 처리하는 라우터입니다.
상품 이미지 업로드 기능이 있어 multer 미들웨어가 붙었습니다.

## 12.2 서버센트 이벤트 사용하기

주기적으로 서버 시간을 조회하는 데는 양방향 통신이 필요하지 않기 때문에 서버센트 이벤트를 사용한다.

서버센트 이벤트와 웹 소켓은 같이 사용할 수 있습니다.

SSE 모듈을 불러와 new SSE(익스프레스 서버)로 서버 객체를 생성하면 됩니다.
생성한 객체에 connection 이벤트 리스너를 연결하여 클라이언트와 연결 시 어떤 동작을 할지 정의할 수 있습니다.
매개변수로 client 객체를 쓸 수 있습니다.
라우터에서 SSE를 사용하고 싶다면 app.set 메서드로 clienct 객체를 등록하고, req.app.get 메서드로 가져오면 됩니다.

clienct.send 메서드로 접속한 클라이언트에게 서버 시간 타임스탬프를 보낼 수 있습니다.
단, 문자열만 보낼 수 있으므로 숫자인 타임스탬프를 toString 메서드를 사용하여 문자열로 변경하였습니다.

서버센트 이벤트는 한 가지 단점이 있습니다.
IE나 엣지 브라우저에서 사용할 수 없다는 것입니다.
EventSource라는 객체를 지원하지 않아서 그렇습니다.
그러나 다행히 EventSource를 사용자가 직접 구현할 수 있습니다.

첫 번째 스크립트가 EventSource Polyfill입니다.
두 번째 스크립트는 EventSource를 사용해서 서버센트 이벤트를 받는 코드입니다.
new EventSource('/sse')로 서버와 연결하고, es.onmessage 또는 es.addEventListener('message') 이벤트 리스너로 서버로부터 데이터를 받을 수 있습니다.
서버로부터 받은 데이터는 e.data에 들어 있습니다.
아랫부분은 서버 시간과 경매 종료 시간을 계산해 카운트다운을 하는 코드입니다.

GET /sse가 바로 서버센트 이벤트에 접속한 것입니다.
Type이 eventSource로 나와 있습니다.
일반 HTTP 연결을 통해 서버센트 이벤트를 사용할 수 있습니다.

먼저 EventSource polyfill과 Socket.IO 클라이언트 스크립트를 넣었습니다.
세 번째 스크립트 태그는 입찰 시 POST /good/:id/bid로 요청을 보내는 것, 서버센트 이벤트 데이터로 서버 시간을 받아 카운트다운을 하는 것, 다른 사람이 입찰했을 때 Socket.IO로 입찰 정보를 렌더링하는 것으로 이루어져 있습니다.

GET /good/:id 라우터는 해당 상품과 기존 입찰 정보들을 불러온 뒤 렌더링합니다.
상품(Good) 모델에 사용자(User) 모델을 include할 때 as 속성을 사용한 것에 주의하세요.
Good 모델과 User 모델은 현재 일대다 관계가 두 번 연결(owner, sold)되어 있으므로 이런 경우에는 어떤 관계를 include할지 as 속성으로 밝혀주어야 합니다.

POST /good/:id/bid는 클라이언트로부터 받은 입찰 정보를 저장합니다.
만약 시작 가격보다 낮게 입찰했거나, 경매 종료 시간이 지났거나, 이전 입찰가보다 낮은 입찰가가 들어왔다면 반려합니다.
정상적인 입찰가가 들어 왔다면 저장 후 해당 경매방의 모든 사ㅏㄻ에게 입찰자, 입찰 가격, 입찰 메시지 등을 웹 소켓으로 전달합니다.
Good.find 메서드의 order 속성을 눈여겨보기 바랍니다.
include될 모델의 컬럼을 정렬하는 방법입니다.

## 12.3 스케줄링 구현하기

schedule 객체의 scheduleJob 메소드로 일정을 예약할 수 있습니다.
첫 번째 인자로 실행될 시각을 넣고, 두 번째 인자로 해당 시각이 되었을 때 수행할 콜백 함수를 넣습니다.

{ 컬럼: sequelize.literal(컬럼 - 숫자) }가 시퀄라이즈에서 해당 컬럼의 숫자를 줄이는 방법입니다.

node-schedule 패키지의 단점은 스케줄링이 노드 기반으로 작동하므로 노드가 종료되면 스케줄 예약도 같이 종료된다는 점입니다.

서버를 재시작하면 앞으로 서버를 시작할 때마다 낙찰자를 지정하는 작업을 수행합니다.

하루가 지나 경매가 마무리되면 node-schedule 모듈이 예정된 스케줄에 따라 낙찰자를 지정합니다.

## 12.4 프로젝트 마무리하기

낙찰된 상품과 그 상품의 입찰 내역을 조회한 후 렌더링합니다.
입찰 내역은 내림차순으로 정렬하여 낙찰자의 내역이 가장 위에 오도록 하였습니다.
