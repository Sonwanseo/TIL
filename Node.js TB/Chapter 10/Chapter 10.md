# Chapter 10. 웹 API 서버 만들기

## 10.1 API 서버 이해하기

API는 다른 애플리케이션에서 현재 프로그램의 기능을 사용할 수 있게 허용하는 접점을 의미합니다.

웹 API는 다른 웹 서비스의 기능을 사용하거나 자원을 가져올 수 있는 창구입니다.
흔히 API를 열었다 또는 만들었다고 표현하는데, 이는 다른 프로그램에서 현재 기능을 사용할 수 있게 허용하였음을 뜻합니다.

크롤링은 웹 사이트가 자체적으로 제공하는 API가 없거나, API 이용에 제한이 있을 때 사용하는 방법입니다.
표면적으로 보이는 웹 사이트의 정보를 일정 주기로 수집해 자체적으로 가공하는 기술입니다.

## 10.2 프로젝트 구조 갖추기

다른 서비스에 NodeBird 서비스의 게시글, 해시태그, 사용자 정보를 JSON 형식으로 제공할 것입니다.
단, 인증을 받은 사용자에게나 일정한 할당량 안에서 API를 호출할 수 있도록 허용할 것입니다.

도메인 모델에는 인터넷 주소와 도메인 종류, 클라이언트 비밀키가 들어갑니다.
클라이언트 비밀키는 API를 사용할 때 필요한 비밀키입니다.

validate는 데이터를 추가로 검증하는 속성입니다.

루트 라우터는 접속 시 로그인 화면을 보여주며, 도메인 등록 라우터는 폼으로부터 온 데이터를 도메인 모델에 저장합니다.

uuid는 범용 고유 식별자로 고유한 문자열을 만들고 싶을 때 사용합니다.

도메인을 등록하는 이유는 등록한 도메인에서만 API를 사용할 수 있게 하기 위해서입니다.
웹 브라우저에서 요청을 보낼 때, 응답을 하는 곳과 도메인이 다르면 CORS 에러가 발생할 수가 있습니다.

## 10.3 JWT 토큰으로 인증하기

JWT는 JSON Web Token의 약어로, JSON 형식의 데이터를 저장하는 토큰입니다.
JWT는 헤더, 페이로드, 시그니처로 구성되어 있습니다.

- 헤더: 토큰 종류와 해시 알고리즘 정보가 들어 있습니다.
- 페이로드: 토큰의 내용물이 인코딩된 부분입니다.
- 시그니처: 일련의 문자열로, 시그니처를 통해 토큰이 변조되었는지 여부를 확인할 수 있습니다.

시그니처는 JWT 비밀키로 만들어집니다.

JWT에는 민감한 내용을 넣어서는 안 됩니다.

JWT 토큰은 JWT 비밀키를 알지 않는 이상 변조가 불가능합니다.
변조한 토큰은 시그니처를 검사할 때 들통납니다.

단점은 용량이 크다는 것입니다.
매 요청 시 토큰이 오고 가기 때문에 데이터 양이 증가합니다.

요청 헤더에 저장된 토큰을 사용합니다.
jwt.verify 메서드로 토큰을 검증할 수 있습니다.
메서드의 첫 번재 인자로는 토큰을, 두 번째 인자로는 토큰의 비밀키를 넣어줍니다.

토큰의 비밀키가 일치하지 않는다면 인증을 받을 수 없습니다.
그런 경우에는 에러가 발생하여 catch문으로 이동하게 됩니다.

sign 메서드의 첫 번째 인자는 토큰의 내용입니다.
두 번째 인자는 토큰의 비밀키입니다.
세 번째 인자는 토큰의 설정입니다.

## 10.4 호출 서버 만들기

API를 통해 가져온 데이터는 JSON 형태이므로 Pug나 EJS 같은 템플릿 엔진으로 데이터를 렌더링할 수도 있습니다.

axios.get(주소, { headers: { 헤더 } })를 하면 해당 주소에 헤더와 함께 GET 요청을 보내는 것이고, axios.post(주소, { 데이터 })를 하면 해당 주소에 POST 요청을 보내면서 요청 본문에 데이터를 실어 보내는 것입니다.
보통 토큰은 HTTP 요청 헤더에 넣어서 보냅니다.
result.data나 tokenResult.data가 API 서버에서 보내주는 응답 값입니다.

## 10.5 SNS API 서버 만들기

결괏값의 코드에 따라 성공 여부를 알 수 있고, 실패한 경우에도 실패 종류를 알 수 있으므로 사용자 입장에서 프로그래밍 시 활용할 수 있습니다.

## 10.6 사용량 제한 구현하기

인증된 사용자더라도 과도하게 API를 사용하면 API 서버에 무리가 갑니다.
따라서 일정 기간 내에 API를 사용할 수 있는 횟수를 제한하여 서버의 트래픽을 줄이는 것이 좋습니다.

apiLimiter 미들웨어를 라우터에 넣으면 라우터에 사용량 제한이 걸립니다.
이 미들웨어의 옵션으로는 windowMs(기준 시간), max(허용 횟수), delayMs(호출 간격), handler(제한 초과 시 콜백함수) 등이 있습니다.

deprecated 미들웨어는 사용하면 안 되는 라우터에 붙여줄 것입니다.

## 10.7 CORS 이해하기

xhr.send 메서드에서 key 부분을 서버가 실제 비밀키로 치환해서 렌더링합니다.

클라이언트에서 서버로 요청을 보낼 때는, 클라이언트와 서버의 도메인이 일치하지 않으면 기본적으로 요청이 차단됩니다.
현재 요청을 보내는 클라이언트와 요청을 받는 서버의 도메인이 다릅니다.
이 문제를 CORS 문제라고 부릅니다.

Network 탭을 보면 Method가 POST 대신 OPTIONS로 표시됩니다.
OPTIONS 메서드는 실제 요청을 보내기 전에 서버가 이 도메인을 허용하는지 체크하는 역할을 합니다.

CORS 문제를 해결하기 위해서는 응답 헤더에 Access-Control-Allow-Origin이라는 헤더를 넣어주어야 합니다.
이 헤더는 클라이언트 도메인의 요청을 허락하겠다는 뜻을 가지고 있습니다.

먼저 도메인 모델로 클라이언트의 도메인과 호스트가 일치하는 것이 있는지 검사합니다.
http나 https 같은 프로토콜을 떼어낼 때는 url.parse 메서드를 사용합니다.

일치하는 것이 있다면 cors를 허용해서 다음 미들웨어로 보내고, 일치하는 것이 없다면 cors 없이 next를 호출합니다.
