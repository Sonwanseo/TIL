# Chapter 2. 알아두어야 할 자바스크립트

## Chapter 2.1 ES2015+

### 2.1.1 const, let

var은 함수 스코프를 가지므로 if문의 블록과 관계없이 접근할 수 있습니다.
하지만 const와 let은 블록 스코프를 가지므로 블록 밖에서는 변수에 접근할 수 없습니다.
블록의 범위는 if, while, for, function 등의 중괄호입니다.

const는 한 번 대입하면 다른 값을 대입할 수 없습니다.
const에 다른 값을 대입하려고 하면 에러가 발생합니다.
또한, 초기화 시 값을 대입하지 않으면 에러가 발생합니다.

자바스크립트를 사용할 때 한 번 초기화했던 변수에 다른 값을 대입하는 경우는 적습니다.
따라서 기본적으로 변수 선언 시에는 const를 사용하고, 다른 값을 대입해야 하는 상황이 생겼을 때 let을 사용하면 됩니다.

### 2.1.2 템플릿 문자열

\${변수} 형식으로 변수를 더하기 기호 없이 문자열에 넣을 수 있습니다.
기존 따옴표 대신 백틱을 사용하기 때문에 큰따옴표나 작은따옴표와 함께 사용할 수도 있습니다.

### 2.1.3 객체 리터럴

객체의 속성명을 동적으로 생성할 수 있습니다.

### 2.1.4 화살표 함수

화살표 함수에서는 function 선언 대신 => 기호로 함수를 선언합니다.
또한, 변수에 대입하면 나중에 재사용할 수 있습니다.

화살표 함수에서는 return문을 줄일 수 있습니다,
소괄호로 감쌀 수도 있습니다.
매개변수가 한 개면 매개변수를 소괄호로 묶어주지 않아도 됩니다.

기존의 function과 다른 점은 this 바인드 방식입니다.

### 2.1.5 비구조화 할당

비구조화 할당 문법도 코드 줄 수를 상당히 줄여주므로 유용합니다.

### 2.1.6 프로미스

자바스크립트와 노드에서는 주로 비동기 프로그래밍을 합니다.
특히 이벤트 주도 방식 때문에 콜백 함수를 자주 사용합니다.

new Promise로 프로미스를 생성할 수 있으며, 안에 resolve와 reject를 매개변수로 갖는 콜백 함수를 넣어줍니다.
이렇게 만든 promise 변수에 then과 catch 메서드를 붙일 수 있습니다.
프로미스 내부에서 resolve가 호출되면 then이 실행되고, rejet가 호출되면 catch가 실행됩니다.

resolve와 reject에 넣어준 인자는 각각 then과 catch의 매개변수에서 받을 수 있습니다.
즉, resolve('성공')가 호출되면 then의 message가 '성공'이 됩니다.

then이나 catch에서 다시 다른 then이나 catch를 붙일 수 있습니다.
이전 then의 return값을 다음 then의 매개변수로 넘깁니다.
프로미스를 return한 경우 프로미스가 수행된 후 다음 then이나 catch가 호출됩니다.

처음 then에서 message를 resolve하면 다음 then에서 받을 수 있습니다.

콜백 함수가 나올 때마다 코드의 깊이가 깊어집니다.
각 콜백 함수마다 에러도 따로 처리해줘야 합니다.

then 메서드들은 순차적으로 실행됩니다.

프로미스 여러 개를 한번에 실행할 수 있는 방법이 있습니다.
Promise.all을 활용하면 간단히 할 수 있습니다.

Promise.resolve는 즉시 resolve하는 프로미스를 만드는 방법입니다.
프로미스가 여러 개 있을 때 Promise.all에 넣으면 모두 resolve될 때까지 기다렸다가 then으로 넘어갑니다.
result 매개변수에 각각의 프로미스 결괏값이 배열로 들어 있습니다.
Promise 중 하나라도 reject가 되면 catcdh로 넘어갑니다.

### 2.1.7 async/await

프로미스의 catch 메서드처럼 try/catch문의 catch가 에러를 처리합니다.

화살표 함수도 async와 같이 사용할 수 있습니다.

for문과 async/await을 같이 써서 Promise.all을 대체할 수도 있습니다.
