# Chapter 2. 알아두어야 할 자바스크립트

## Chapter 2.1 ES2015+

### 2.1.1 const, let

var은 함수 스코프를 가지므로 if문의 블록과 관계없이 접근할 수 있습니다.
하지만 const와 let은 블록 스코프를 가지므로 블록 밖에서는 변수에 접근할 수 없습니다.
블록의 범위는 if, while, for, function 등의 중괄호입니다.

const는 한 번 대입하면 다른 값을 대입할 수 없습니다.
const에 다른 값을 대입하려고 하면 에러가 발생합니다.
또한, 초기화 시 값을 대입하지 않으면 에러가 발생합니다.

자바스크립트를 사용할 때 한 번 초기화했던 변수에 다른 값을 대입하는 경우는 적습니다.
따라서 기본적으로 변수 선언 시에는 const를 사용하고, 다른 값을 대입해야 하는 상황이 생겼을 때 let을 사용하면 됩니다.

### 2.1.2 템플릿 문자열

\${변수} 형식으로 변수를 더하기 기호 없이 문자열에 넣을 수 있습니다.
기존 따옴표 대신 백틱을 사용하기 때문에 큰따옴표나 작은따옴표와 함께 사용할 수도 있습니다.

### 2.1.3 객체 리터럴

객체의 속성명을 동적으로 생성할 수 있습니다.

### 2.1.4 화살표 함수

화살표 함수에서는 function 선언 대신 => 기호로 함수를 선언합니다.
또한, 변수에 대입하면 나중에 재사용할 수 있습니다.

화살표 함수에서는 return문을 줄일 수 있습니다,
소괄호로 감쌀 수도 있습니다.
매개변수가 한 개면 매개변수를 소괄호로 묶어주지 않아도 됩니다.

기존의 function과 다른 점은 this 바인드 방식입니다.

### 2.1.5 비구조화 할당

비구조화 할당 문법도 코드 줄 수를 상당히 줄여주므로 유용합니다.

### 2.1.6 프로미스

자바스크립트와 노드에서는 주로 비동기 프로그래밍을 합니다.
특히 이벤트 주도 방식 때문에 콜백 함수를 자주 사용합니다.

new Promise로 프로미스를 생성할 수 있으며, 안에 resolve와 reject를 매개변수로 갖는 콜백 함수를 넣어줍니다.
이렇게 만든 promise 변수에 then과 catch 메서드를 붙일 수 있습니다.
프로미스 내부에서 resolve가 호출되면 then이 실행되고, rejet가 호출되면 catch가 실행됩니다.

resolve와 reject에 넣어준 인자는 각각 then과 catch의 매개변수에서 받을 수 있습니다.
즉, resolve('성공')가 호출되면 then의 message가 '성공'이 됩니다.

then이나 catch에서 다시 다른 then이나 catch를 붙일 수 있습니다.
이전 then의 return값을 다음 then의 매개변수로 넘깁니다.
프로미스를 return한 경우 프로미스가 수행된 후 다음 then이나 catch가 호출됩니다.

처음 then에서 message를 resolve하면 다음 then에서 받을 수 있습니다.

콜백 함수가 나올 때마다 코드의 깊이가 깊어집니다.
각 콜백 함수마다 에러도 따로 처리해줘야 합니다.

then 메서드들은 순차적으로 실행됩니다.

프로미스 여러 개를 한번에 실행할 수 있는 방법이 있습니다.
Promise.all을 활용하면 간단히 할 수 있습니다.

Promise.resolve는 즉시 resolve하는 프로미스를 만드는 방법입니다.
프로미스가 여러 개 있을 때 Promise.all에 넣으면 모두 resolve될 때까지 기다렸다가 then으로 넘어갑니다.
result 매개변수에 각각의 프로미스 결괏값이 배열로 들어 있습니다.
Promise 중 하나라도 reject가 되면 catcdh로 넘어갑니다.

### 2.1.7 async/await

프로미스의 catch 메서드처럼 try/catch문의 catch가 에러를 처리합니다.

화살표 함수도 async와 같이 사용할 수 있습니다.

for문과 async/await을 같이 써서 Promise.all을 대체할 수도 있습니다.

## 2.2 프런트엔드 자바스크립트

### 2.2.1 AJAX

AJAX는 비동기적 웹 서비스를 개발하기 위한 기법입니다.
쉽게 말해 페이지 이동 없이 서버에 요청을 보내고 응답을 받는 기술입니다.

보통 AJAX 요청은 jQuery나 axios 같은 라이브러리를 이용해서 보냅니다.

먼저 XMLHttpRequest 생성자로 xhr 객체를 생성합니다.
xhr.open 메서드에 요청 메서드와 요청 주소를 넣고 xhr.send 메서드로 보내면 됩니다.
xhr.onreadystatechange는 이벤트 리스너로 요청한 후 서버로부터 응답이 올 때 응답을 받을 수 있습니다.
응답 코드가 200번 대 숫자면 성공을 의미하므로 xhr.requestText에는 성공한 내용이 담겨 있을 것이고, 그렇지 않다면 에러 메시지가 담겨 있을 것입니다.

### 2.2.2 FormData

HTML form 태그의 데이터를 동적으로 제어할 수 있는 기능입니다.

먼저 FormData 생성자로 formData 객체를 만듭니다.
생성된 객체의 append 메서드로 키-값 형식의 데이터를 저장할 수 있습니다.
append 메서드를 여러 번 사용해서 키 하나에 여러 개의 값을 추가해도 됩니다.
has 메서드는 주어진 키에 해당하는 값이 있는지 여부를 알려줍니다.
get 메서드는 주어진 키에 해당하는 값 하나를 가져오고, getAll 메서드는 해당하는 모든 값을 가져옵니다.
delete는 현재 키를 제거하는 메서드고, set은 현재 키를 수정하는 메서드입니다.

### 2.2.3 encodeURIComponent, decodeURIComponent

서버가 한글 주소를 이해하지 못하는 경우가 있는데, 이럴 때 window 객체의 메서드인 encodeURIComponent 메서드를 사용합니다.

한글 주소 부분만 encodeURIComponent 메서드로 감싸줍니다.

받는 쪽에서 decodeURIComponent를 사용하면 됩니다.

### 2.2.4 data attribute와 dataset

노드를 웹 서버로 사용하는 경우, 클라이언트(프런트엔드)와 빈번하게 데이터를 주고받게 됩니다.

프런트엔드에 데이터를 내려보낼 때 첫 번째로 고려해야 할 점은 보안입니다.

보안과 관련이 없는 데이터들은 자유롭게 프런트엔드로 보내도 됩니다.
HTML5에도 HTML과 관련된 데이털르 저장하는 공식적인 방법이 있습니다.
바로 data attribute입니다.

data attribute의 장점은 자바스크립트로 쉽게 접근할 수 있다는 점입니다.
앞의 data- 접두어는 사라지고 - 뒤에 위치한 글자는 대문자가 됩니다.

반대로 dataset에 데이터를 넣어도 HTML 태그에 반영됩니다.
