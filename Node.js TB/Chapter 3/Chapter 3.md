# 노드 기능 알아보기

## 3.1 REPL 사용하기

자바스크립트는 스크립트 언어이므로 미리 컴파일을 하지 않아도 즉석에서 코드를 실행할 수 있습니다.
노드도 비슷한 콘솔을 제공하는데, 입력한 코드를 읽고, 해석하고, 결과물을 반환하고, 종료할 때까지 반복한다고 해서 REPL이라고 부릅니다.

프롬프트가 > 모양으로 바뀌었다면 자바스크립트 코드를 입력할 수 있습니다.

REPL은 한두 줄짜리 코드를 테스트해보는 용도로는 좋지만 여러 줄의 코드를 실행하기에는 불편합니다.
긴 코드는 코드를 자바스크립트 파일로 만든 후, 파일을 통째로 실행하는 것이 좋습니다.

## 3.3 모듈로 만들기

모듈이란 특정한 기능을 하는 함수나 변수들의 집합입니다.

모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있습니다.

보통 파일 하나가 모듈 하나가 됩니다.
파일별로 코드를 모듈화할 수 있어 관리하기 편합니다.

require 함수 안에 불러올 모듈의 경로를 적어줍니다.

module.exports에는 객체만 대입해야 하는 것이 아니라 함수나 변수를 대입해도 됩니다.

모듈 하나가 여러 개의 모듈을 사용할 수 있습니다.
모듈 하나가 여러 개의 모듈에 사용될 수도 있습니다.

모듈로부터 값을 불러올 때 변수 이름을 다르게 지정할 수도 있습니다.

여러 파일에 걸쳐 재사용되는 함수나 변수들을 모듈로 만들어두면 편리합니다.

## 3.4 노드 내장 객체 알아보기

노드에서는 기본적인 내장 객체와 내장 모듈을 제공합니다.
그래서 따로 설치하지 않아도 바로 사용할 수 있습니다.

### 3.4.1 global

전역 객체이므로 모든 파일에서 접근할 수 있습니다.

global 객체 내부에는 매우 많은 속성이 들어 있습니다.
내부를 보려면 REPL을 이용해야 합니다.

전역 객체라는 점을 이용하여 간단한 데이터를 파일끼리 공유할 때 사용하기도 합니다.

### 3.4.2 console

console 객체는 보통 디버깅을 위해 사용됩니다.

- console.time(레이블): console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정합니다.
- console.log(내용): 평범한 로그를 콘솔에 표시합니다. console.log(내용, 내용, ...)처럼 여러 내용을 동시에 표시할 수도 있습니다.
- console.error(에러 내용): 에러를 콘솔에 표시합니다.
- console.dir(객체, 옵션): 객체를 콘솔에 표시할 때 사용합니다. 첫 번째 인자로 표시할 객체를 넣고, 두 번째 인자로 옵션을 넣습니다. 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 보기가 한결 편해집니다. depth는 객체 안의 객체를 몇 단계까지 보여줄지를 결정합니다. 기본값은 2입니다.
- console.trace(레이블): 에러가 어디서 발생했는지 추적할 수 있게 해줍니다. 보통은 에러 발생 시 에러 위치를 알려주므로 자주 사용하지는 않지만, 위치가 나오지 않는다면 사용할 만합니다.

### 3.4.4 **filename, **dirname

노드는 **filename, **dirname이라는 키워드로 경로에 대한 정보를 제공합니다.

### 3.4.5 module, exports

지금까지는 모듈을 만들 때 module.exports만 사용했는데, module 객체 말고 exports 객체로도 모듈을 만들 수 있습니다.

module.exports와 exports가 같은 객체를 참조한다.

### 3.4.6 process

process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고 있습니다.

일반적으로 운영체제나 실행 환경별로 다른 동작을 하고 싶을 때 사용합니다.

#### 3.4.6.1 process.env

REPL에 proceses.env를 입력하면 매우 많은 정보가 출력됩니다.
자세히 보면 이 정보들이 시스템의 환경 변수임을 알 수 있습니다.

process.env는 서비스의 중요한 키를 저장하는 공간으로도 사용됩니다.

#### 3.4.6.2 process.nextTick(콜백)

이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하도록 만듭니다.

process.nextTick은 setImmediate나 setTimeout보다 먼저 실행됩니다.
코드 맨 밑에 Promise를 넣은 것은 resolve된 Promise도 nextTick처럼 다른 콜백들보다 우선시되기 때문입니다.
그래서 process.nextTick과 Promise를 마이크로태스크라고 따로 구분지어 부릅니다.

#### 3.4.6.3 process.exit(코드)

실행 중인 노드 프로세스를 종료합니다.
서버에 이 함수를 사용하면 서버가 멈추므로 서버에는 거의 사용하지 않습니다.
하지만 서버 외의 독립적인 프로그램에서는 수동으로 노드를 멈추게 하기 위해 사용합니다.

### 3.5 노드 내장 모듈 사용하기

#### 3.5.1 os

os.constants 객체 안에는 각종 에러와 신호에 대한 정보가 담겨 있습니다.

os 모듈은 주로 컴퓨터 내부 자원에 빈번하게 접근하는 경우 사용됩니다.

#### 3.5.2 path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈입니다.
path 모듈이 필요한 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문입니다.

#### 3.5.3 url

인터넷 주소를 쉽게 조작하도록 도와주는 모듈입니다.

WHATWG 방식은 search 부분을 searchParams라는 특수한 객체롤 반환하므로 유용합니다.
search 부분은 보통 주소를 통해 데이터를 전달할 때 사용됩니다.
search는 물음표(?)로 시작하고, 그 뒤에 키=값 형식으로 데이터를 전달합니다.
여러 키가 있을 경우에는 &로 구분합니다.

#### 3.5.4 querystring

WHATWG 방식의 url 대신 기존 노드의 url을 사용할 때 search 부분을 사용하기 쉽게 객체로 만드는 모듈입니다.

- querystring.parse(쿼리): url의 query 부분을 자바스크립트 객체로 분해해줍니다.
- querystring.stringify(객체): 분해된 query 객체를 문자열로 다시 조립해줍니다.

#### 3.5.5 crypto

##### 3.5.5.1 단방향 암호화

비밀번호는 보통 단방향 암호화 알고리즘을 사용해서 암호화합니다.
단방향 암호화란 복호화할 수 없는 암호화 방식을 뜻합니다.
복호화는 암호화된 문자열을 원래 문자열로 되돌려놓는 것을 의미합니다.
즉, 단방향 암호화는 한 번 암호화하면 원래 문자열을 찾을 수 없습니다.

단방향 암호화 알고리즘은 주로 해시 기법을 사용합니다.
해시 기법이란 어떠한 문자열을 고정된 길이의 다른 문자열로 바꿔버리는 방식입니다.
입력 문자열의 길이는 다르지만, 출력 문자열의 길이는 네 자리로 고정되어 있습니다.

먼저 randomBytes() 메서드로 64바이트 길이의 문자열을 만들어줍니다.
이것이 salt가 됩니다.
pbkdf2() 메서드에는 순서대로 비밀번호, salt, 반복 횟수, 출력 바이트, 해시 알고리즘을 인자로 넣어줍니다.

##### 3.5.2 양방향 암호화

암호화된 문자열을 복호화할 수 있습니다.
여기에서는 키(열쇠)라는 것이 사용됩니다.
암호를 복호화하려면 암호화할 때 사용한 키와 같은 키를 사용해야 합니다.

#### 3.5.6 uril

각종 편의 기능을 모아둔 모듈입니다.

### 3.6 파일 시스템 접근하기

fs 모듈은 파일 시스템에 접근하는 모듈입니다.
즉, 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있습니다.
폴더도 만들었다 지웠다 할 수 있습니다.

fs 모듈을 불러온 뒤 읽을 파일의 경로를 지정합니다.
유의할 점은 콜백 함수도 readFile 메서드의 인자로 같이 넣어준다는 것입니다.
이 콜백 함수의 매개변수로 에러 또는 데이터를 받습니다.

readFile의 결과물은 버퍼라는 형식으로 제공됩니다.

#### 3.6.1 동기 메서드와 비동기 메서드

노드는 대부분의 메서드를 비동기 방식으로 처리합니다.
하지만 몇몇 메서드는 동기 방식으로도 사용할 수 있습니다.
특히 fs 모듈이 그러한 메서드를 많이 가지고 있습니다.

비동기 메서드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어갑니다.
나중에 읽기가 완료되면 백그라운드가 다시 메인 스레드에 알림을 줍니다.
메인 스레드는 그제서야 등록된 콜백 함수를 실행합니다.

이 방식은 상당히 좋습니다.
수백 개의 I/O 요청이 들어와도 메인 스레드는 백그라운드에 요청 처리를 위임합니다.
그 후로도 얼마든지 요청을 더 받을 수 있습니다.
나중에 백그라운드가 각각의 요청 처리가 완료되었다고 알리면 그때 콜백 함수를 처리하면 됩니다.

readFileSync 메서드를 사용하면 요청이 수백 개 이상 들어왔을 때 성능에 문제가 생깁니다.
Sync 메서드를 사용할 때는 이전 작업이 완료되어야 다음 작업을 진행할 수 있습니다.
즉, 백그라운드가 작업하는 동안 메인 스레드는 아무것도 못하고 대기하고 있어야 하는 것입니다.
메인 스레드가 일을 하지 않고 노는 시간이 생기기 때문에 비효율적입니다.

동기 메서드들은 이름 뒤에 Sync가 붙어 있어 구분하기 쉽습니다.
하지만 동기 메서드를 사용해야 하는 경우는 극히 드뭅니다.

콜백 지옥은 Promise나 async/await로 어느 정도 해결할 수 있습니다.

toString 메서드를 사용하는 이유는 data가 버퍼이기 때문입니다.

#### 3.6.2 버퍼와 스트림 이해하기

파일을 읽거나 쓰는 방식에는 크게 두 가지 방식, 즉 버퍼를 이용하는 방식과 스트림을 이용하는 방식이 있습니다.

노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며, 파일 데이터를 메모리에 저장한 뒤 사용자가 조회할 수 있도록 해줍니다.
메모리에 저장된 데이터가 바로 버퍼입니다.

Buffer 객체는 여러 가지 메서드를 제공합니다.

readFile() 방식의 버퍼가 편리하기는 하지만 문제점도 있습니다.

파일을 읽는 스트림 메서드는 createReadStream이 있습니다.

먼저 createReadStream()으로 읽기 스트림을 만들어줍니다.
첫 번째 인자로 읽을 파일 경로를 넣습니다.
두 번째 인자는 옵션 객체인데, highWaterMark라는 옵션이 버퍼의 크기(바이트 단위)를 정할 수 있는 옵션입니다.

먼저 createWriteStream()으로 쓰기 스트림을 만들어줍니다.
첫 번째 인자로는 출력 파일명을 입력합니다.
두 번째 인자는 옵션입니다.

finish 이벤트 리스너는 파일 쓰기가 종료되면 콜백 함수가 호출됩니다.

writeStream에서 제공하는 write() 메서드로 넣을 데이터를 씁니다.
여러 번 호출할 수 있습니다.
데이터를 다 썼다면 end()메서드로 종료를 알려줍니다.
이때 finish 이벤트가 발생합니다.

createReadStream으로 파일을 읽고 그 스트림을 전달받아 createWriteStream으로 파일을 쓸 수도 있습니다.
스트림끼리 연결하는 것을 '파이핑한다'고 표현합니다.

미리 읽기 스트림과 쓰기 스트림을 만들어둔 후 두 개의 스트림 사이클 pipe 메서드로 연결해주면 저절로 데이터가 writeStream으로 넘어갑니다.

pipe는 스트림 사이에 연결할 수 있습니다.

노드에서는 파일을 압축하는 zlib이라는 모듈도 제공합니다.
zlib의 createGzip()이라는 메서드가 스트림을 지원하므로 readStream과 writeStream 중간에서 파이핑을 할 수 있습니다.
버퍼 데이터가 전달되다가 gzip 압축을 거친 후 파일로 쓰여집니다.

#### 3.6.3 기타 fs 메서드

fs는 파일 시스템을 조작하는 다양한 메서드를 제공합니다.
파일을 생성하고 삭제할 수도 있고, 폴더를 생성하고 삭제할 수도 있습니다.
