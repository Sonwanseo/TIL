# 3. TS for OOP Programmers

TS는 C#, Java와 같이 정적 타이핑을 사용하는 언어에 익숙한 프로그래머들에게 인기 있는 선택이다.

TS의 타입 시스템은 더 나은 코드 완성, 오류의 조기 발견, 프로그램 부분 간의 더 명확한 통신과 같이 정적 타이핑이 가지는 많은 이점을 제공한다.  

### JavaScript 함께 배우기

TS 모델이 유형화하는 방법 중 일부는 Java나 C#과 상당히 다르며, TS를 학습하는 데에 있어 이 부분을 염두에 두는 것이 중요하다.

만약 JS를 처음 접하는 Java나 C# 프로그래머라면, JS의 런타임 동작을 이해하기 위해 우선적으로 타입을 제외한 JS의 일부분을 배우는 것이 좋다.  
TS는 코드를 실행하는 방식을 바꾸지 않기 때문에, 실제로 무언가 동작하는 코드를 작성하기 위해서는 여전히 JS가 어떻게 작동하는지 배워야 한다.

TS가 JS와 동일한 런타임을 사용하므로, 특정한 런타임 동작을 구현하려는 리소스는 항상 TS 프로그램에서도 잘 적용된다.

### 클래스 다시 생각하기

C#과 Java는 의무적 OOP 언어라고 부른다.  
이러한 언어에서 클래스는 코드 구성의 기본 단위일 뿐만 아니라 런타임 시 모든 데이터 그리고 동작의 기본적인 컨테이너다.  
기능과 데이터를 전부 클래스에 담도록 강제하는 것은 일부 문제에 대해선 좋은 도메인 모델이 될 수 있지만, 모든 도메인이 이러한 방식으로 표현될 필요는 없다.

#### 자유로운 함수와 데이터

JS에서 함수는 어디에나 있을 수 있고, 데이터를 미리 정의된 class나 struct에 속하지 않고 자유롭게 전달할 수 있다.  
OOP 계층과 상관 없이 데이터를 처리하는 자유로운 함수는 프로그램을 JS로 작성하는 모델로 선호된다.

#### 정적 클래스

추가적으로, C#과 Java의 싱글턴과 정적 클래스 같은 특정 구조는 TS에서 필요하지 않다.

### TS의 OOP

TS는 인터페이스, 상속, 정적 메서드 구현과 같은 많은 일반적인 패턴을 지원한다.

### 타입 다시 생각하기

TS의 타입에 대한 이해는 C#이나 Java와 상당히 다르다.

#### 이름으로 구체화된 타입 시스템

C#과 Java에서 주어진 값과 객체는 null, 원시 타입, 또는 정의된 클래스 타입 중 정확하게 하나의 타입을 가진다.  
런타임 시점에서 정확한 타입을 묻기 위해 value.getType() 또는 value.getClass()와 같은 메서드를 호출할 수 있다.  
이러한 타입의 정의는 특정한 이름을 갖고 클래스의 어딘가에 존재하며, 명시적인 상속 관계나 공통적으로 구현된 인터페이스가 없는 이상 두 클래스가 유사한 형태를 가졌다 해도 서로 대체하여 사용할 수 없다.

이러한 양상은 reified, nominal 타입 시스템을 설명한다.  
코드에서 사용한 타입은 런타임 시점에 존재하며, 타입은 구조가 아닌 선언을 통해 연관 지어진다.

#### 집합으로서의 타입

C# 또는 Java에서 런타임 타입과 해당 컴파일 타임 선언 사이의 일대일 대응관계는 중요하다.

TS에서 타입은 공통의 무언가를 공유하는 값의 집합으로 생각하는 것이 좋다.  
타입은 집합에 불과하기 때문에, 특정한 값은 동시에 수많은 집합에 속할 수 있다.

TS는 집합론에 의거해 타입을 이용하는 여러 방법을 제공하며, 타입을 집합으로 생각하는 것이 더 직관적이다.

#### 삭제된 구조적 타입

TS에서, 객체는 정확히 단일 타입이 아니다.  
예를 들어 인터페이스를 만족하는 객체를 생성할 때, 둘 사이의 선언적인 관계가 없더라도 해당 인터페이스가 예상되는 곳에 해당 객체를 사용할 수 있다.

TS의 타입 시스템은 명목이 아닌 구조적이다.

또한 TS의 타입 시스템은 구체화되지 않았다.

#### 구조적 타입화의 결과

객체지향 프로그래머는 종족 구조적 타입화의 두 가지 측면에 놀라곤 한다.

##### 빈 타입

첫 번째로 빈 타입은 예상을 무시하는 것처럼 보인다.

```typescript
class Empty {}

function fn(arg: Empty) {
  // 무엇인가를 하나요?
}

// 오류 X
fn({ k: 10 });
```

TS는 주어진 인수가 유효한 Empty인지 확인하여 fn의 호출이 유효한지를 검사한다.  
Empty에 프로퍼티가 없으므로 Empty가 수행하는 모든 프로퍼티가 { k: 10 }에 속해있다.  
그러므로 유효한 호출이다.

##### 동일한 타입

```typescript
class Car {
  drive() {
    // hit the gas
  }
}

class Golfer {
  drive() {
    // hit the ball far
  }
}

// No error?
let w: Car = new Golfer();
```

오류가 아닌 이유는 클래스의 구조가 동일하기 때문이다.

#### 반영

객체지향 프로그래머는 제네릭을 포함하여 어떤 값의 유형이라도 다룰 수 있음에 익숙하다.

TS의 타입 시스템이 완벽히 지워졌으므로, 제네릭 타입 인자의 인스턴스화와 같은 정보는 런타임에 사용할 수 없다.