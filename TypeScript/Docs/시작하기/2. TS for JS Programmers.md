# 2. TS for JS Programmers

현대 프로그래밍 언어에서 TS와 JS의 관계는 다소 독특하다.  
TS는 JS 위에 레이어로서 자리잡고 있는데, JS의 기능들을 제공하면서 그 위에 자체 레이어를 추가한다.  
이 레이어가 TS 타입 시스템이다.

JS는 이미 원시 타입을 가지고 있지만, 전체 코드베이스에 일관되게 할당되었는지는 미리 확인해주지 않는다.  
TS는 이 레이어로서 동작한다.

이는 잘 동작하는 JS 코드는 동시에 TS 코드라는 의미지만, TS의 타입 검사기는 사용자가 생각한 일과 JS가 실제로 하는 일 사이의 불일치를 강조할 수 있다.

### 타입 추론

TS는 JS 언어를 알고 있으며 대부분의 경우 타입을 생성해준다.  
예를 들어 변수를 생성하면서 동시에 특정 값을 할당하는 경우, TS는 그 값을 해당 변수의 타입으로 사용한다.

JS가 동작하는 방식을 이해함으로써 TS는 JS 코드를 받아들이면서 타입을 가지는 타입 시스템을 구출할 수 있다.  
이는 코드에서 타입을 명시하기 위해 추가로 문자를 사용할 필요가 없는 타입 시스템을 제공한다.

### 타입 정의하기

JS는 다양한 디자인 패턴을 가능하게 하는 동적 언어다.  
몇몇 디자인 패턴은 자동으로 타입을 제공하기 힘들 수 있는데 이러한 경우에 TS는 TS에게 타입이 무엇이 되어야 하는지 명시 가능한 JS 언어의 확장을 지원한다.

객체의 형태를 명시적으로 나타내기 위해 interface를 선언할 수 있다.

변수 선언 뒤에 : TypeName의 구문을 사용하여 타입을 지정할 수 있다.

해당 타입에 맞지 않는 객체 또는 변수를 생성하면 TS는 경고를 준다.

JS는 클래스와 객체 지향 프로그래밍을 지원하기 때문에, TS도 동일하다.  
인터페이스는 클래스로도 선언할 수 있다.

인터페이스는 함수에서 매개변수와 리턴 값을 명시하는데 사용되기도 한다.

JS에서 사용할 수 있는 원시 타입이 있다.  
TS는 몇 가지를 추가해 목록을 확장한다.  
예를 들어, any, unknown, never 등이 있다.

타입을 구축하기 위한 두 가지 구문이 존재한다.  
interface를 우선적으로 사용하고 특정 기능이 필요할 때 type을 사용해야 한다.

### 타입 구성

객체들을 조합하여 더 크고 복잡한 객체를 만드는 방법과 유사하게 TS에 타입으로 이를 수행하는 도구가 있다.  
여러가지 타입을 이용하여 새 타입을 작성하기 위해 가장 많이 사용되는 두 가지 코드로는 유니언과 제네릭이 있다.

#### 유니언

유니언은 타입이 여러 타입 중 하나일 수 있음을 선언하는 방법이다.

```typescript
type MyBool = true | false;
```

#### 제네릭

제네릭은 타입에 변수를 제공하는 방법이다.

배열이 일반적인 예시이며, 제네릭이 없는 배열은 어떤 것이든 포함할 수 있다.  
제네릭이 있는 배열은 배열 안의 값을 설명할 수 있다.

제네릭을 사용하는 고유 타입을 선언할 수 있다.

### 구조적 타입 시스템

TS의 핵심 원칙 중 하나는 타입 검사가 값이 있는 형태에 집중한다는 것이다.  
이는 "덕 타이핑" 또는 "구조적 타이핑"이라고 불린다.

구조적 타입 시스템에서 두 객체가 같은 형태를 가지면 같은 것으로 간주된다.

```typescript
interface Point {
  x: number;
  y: number;
}

function printPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

// "12, 26"을 출력합니다.
const point = { x: 12, y: 26 };
printPoint(point);
```

point 변수는 Point 타입으로 선언된 적 없지만, TS는 타입 검사에서 point의 형태와 Point의 형태를 비교한다.

형태 일치에는 일치시킬 객체의 필드의 하위 집합만 필요하다.

마지막으로, 구조적으로 클래스와 객체가 형태를 따르는 방법에는 차이가 없다.

객체 또는 클래스에 필요한 모든 속성이 존재한다면, TS는 구현 세부 정보에 관계없이 일치하게 본다.