# Chapter 14. 비동기적 프로그래밍

자바스크립트 애플리케이션은 단일 스레드에서 동작한다.
즉, 자바스크립트는 한 번에 한 가지 일만 할 수 있다.

부드럽게 동작하는 소프트웨어를 만들기 위해서는 사용자의 입력뿐만 아니라 여러 문제를 비동기적 관점에서 생각해야 한다.

자바스크립트의 비동기적 프로그래밍에는 뚜렷이 구분되는 세 가지 패러다임이 있다.
처음에는 콜백이 있었고, 프라미스가 뒤를 이었으며 마지막은 제너레이터이다.
제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야 한다.
프라미스 역시 콜백에 의존한다.
콜백은 제너레이터나 프라미스 외에도 이벤트 처리 등에 유용하게 쓸 수 있다.

사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세 가지가 있다.

- Ajax 호출을 비롯한 네트워크 요청
- 파일을 읽고 쓰는 등의 파일시스템 작업
- 의도적으로 시간 지연을 사용하는 기능(알람 등)

### 14.2 콜백

콜백은 간단히 말해 나중에 호출할 함수이다.
콜백 함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용한다.
콜백은 보통 익명 함수로 사용한다.

비동기적 실행의 가장 큰 목적, 가장 중요한 요점은 어떤 것도 차단하지 않는다는 것이다.

#### 14.2.1 setInterval과 clearInterval

setTimeout은 콜백 함수를 한 번만 실행하고 멈추지만, setInterval은 콜백을 정해진 주기마다 호출하며 clearInterval을 사용할 때까지 멈추지 않는다.

setTimeout, setInterval, clearInterval은 모두 전역 객체(브라우저에서는 window, 노드에서는 global)에 정의되어 있다.

#### 14.2.2 스코프와 비동기적 실행

함수를 호출하면 항상 클로저가 만들어진다.
매개변수를 포함해 함수 안에서 만든 변수는 모두 무언가가 자신에 접근할 수 있는 한 계속 존재한다.

setTimeout을 호출하는 것 역시 동기적이다.
setTimeout을 동기적으로 호출해야만 콜백을 언제 호출할지 계산할 수 있다.

#### 14.2.3 오류 우선 콜백

콜백을 사용하면 예외 처리가 어려워지므로, 콜백과 관련된 에러를 처리할 방법의 표준이 필요했다.
이에 따라 나타난 패턴이 콜백의 첫 번째 매개변수에 에러 객체를 쓰자는 것이었다.
에러가 null이나 undefined이면 에러가 없는 것이다.

#### 14.2.4 콜백 헬

콜백을 사용해 비동기적으로 실행할 수 있긴 하지만, 현실적인 단점이 있다.
한 번에 여러가지를 기다려야 한다면 콜백을 관리하기가 상당히 어려워진다.

### 14.3 프라미스

프라미스는 콜백의 단점을 해결하려는 시도 속에서 만들어졌다.

프라미스 기반 비동기적 함수를 호출하면 그 함수는 Promise 인스턴스를 반환한다.
프라미스는 성공하거나, 실패하거나 단 두 가지뿐이다.

프라미스는 객체이므로 어디든 전달할 수 있다는 점도 콜백에 비해 간편한 장점이다.

#### 14.3.1 프라미스 만들기

프라미스는 쉽게 만들 수 있다.
resolve(성공)와 reject(실패) 콜백이 있는 함수로 새 Promise 인스턴스를 만들기만 하면 된다.

#### 14.3.2 프라미스 사용

then 핸들러는 성공 콜백과 에러 콜백을 받는다.
프라미스는 catch 핸들러도 지원하므로 핸들러를 둘로 나눠서 써도 된다.

#### 14.3.3 이벤트

이벤트가 일어나면 이벤트 발생을 담당하는 개체에서 이벤트가 일어났음을 알린다.
필요한 이벤트는 모두 주시할 수 있다.
노드에는 이벤트를 지원하는 모듈 EventEmitter가 내장돼 있다.

EventEmitter를 상속하는 클래스는 이벤트를 발생시킬 수 있다.

#### 14.3.4 프라미스 체인

프라미스에는 체인으로 연결할 수 있다는 장점이 있다.
즉, 프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출할 수 있다.

프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요는 없다.
체인 어디에서든 에러가 생기면 체인 전체가 멈추고 catch 핸들러가 동작한다.

#### 14.3.5 결정되지 않는 프라미스 방지하기

프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지한다.

결정되지 않은 프라미스를 방지하는 한 가지 방법은 프라미스에 타임아웃을 거는 것이다.

프라미스를 반환하는 어떤 함수에든 타임아웃을 걸 수 있다.

### 14.4 제너레이터

제너레이터는 원래 동기적인 성격을 가졌지만, 프라미스와 결합하면 비동기 코드를 효율적으로 관리할 수 있다.

grun은 기초적인 제너레이터 재귀 실행기이다.
grun에서 제너레이터 함수를 넘기면 해당 함수가 실행된다.
yield로 값을 넘긴 제너레이터는 이터레이터에서 next를 호출할 때까지 기다린다.
grun은 그 과정을재귀적으로 반복한다.
이터레이터에서 프라미스르 반환하면 grun은 프라미스가 완료될 때까지 기다린 다음 이터레이터 실행을 재개한다.
이터레이터가 값을 반환하면 이터레이터 실행을 즉시 재개한다.
grun에서 iterate를 바로 호출하지 않고 setTimeout을 거친 이유는 효율성 때문이다.
자바스크립트 엔진은 재귀 호출을 비동기적으로 실행할때 메모리를 좀 더 빨리 회수한다.

#### 14.4.1 1보 전진과 2보 후퇴?

Promise에는 all 메서드가 있다.
이 메서드는 배열로 받은 프라미스가 모두 완료될 때 완료되며, 가능하다면 비동기적 코드를 동시에 실행한다.

#### 14.4.3 제너레이터 실행기와 예외 처리

제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리를 할 수 있다는 것도 중요한 장점이다.
콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다.
콜백에서 일으킨 예외는 그 콜백 밖에서 캐치할 수 없다.

### 14.5 요약

- 자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.
- 프라미스를 콜백 대신 사용할 수 있는 건 아니다. 프라미스 역시 콜백을 사용한다.
- 프라미스는 콜백이 여러 번 호출되는 문제를 해결했다.
- 콜백을 여러 번 호출해야 한다면 이벤트와 결합하는 방법을 생각할 수 있다(프라미스도 함께 쓸 수 있다).
- 프라미스는 반드시 결정된다는(성공 또는 실패한다는) 보장은 없다. 프라미스에 타임아웃을 걸면 이 문제가 해결된다.
- 프라미스는 체인으로 연결할 수 있다.
- 프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 그대로 유지하면서도 동기적인 사고방식으로 문제를 해결할 수 있다.
- 제너레이터를 써서 동기적인 사고방식으로 문제를 해결할 때는 프로그램의 어느 부분을 동시에 실행할 수 있는지 잘 살펴야 한다. 동시에 실행할 수 있는 부분은 Promise.all을 써서 실행해라.
- 제너레이터 실행기를 직접 만드는 고생을 하지 말고 co나 Koa를 써라.
- 노드 스타일 콜백을 프라미스로 바꾸는 고생도 필요 없다. Q를 써라.
- 제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.
