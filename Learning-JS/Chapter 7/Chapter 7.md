# Chapter 7. 스코프

스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다.

변수와 상수는 만들기 전에는 존재하지 않는다.

### 7.1 스코프와 존재

가시성이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트에서 현재 보이고 접근할 수 있는 식별자들을 말한다.

무언가가 더는 존재하지 않는다고 해도 자바스크립트는 메모리를 바로 회수하지 않는다.
그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 가비지 콜렉션 프로세스에서 메모리를 회수한다.
JS의 가비지 콜렉션은 자동으로 일어나며, CPU나 메모리를 심하게 혹사하는 애플리케이션이 아니라면 프로그래머가 신경 쓸 필요 없다.

### 7.2 정적 스코프와 동적 스코프

프로그램의 소스 코드를 살펴보는 건 그 프로그램의 정적(어휘적, lexical) 구조를 살펴보는 것이다.

자바스크립트의 스코프는 정적이다.
소스 코드만 봐도 변수가 스코프에 있는 지 판단할 수 있다.

정적 스코프는 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻이다.

자바스크립트의 정적 스코프는 전역 스코프와 블록 스코프, 함수 스코프에 적용된다.

### 7.3 전역 스코프

프로그램을 시작할 때 암시적으로 주어지는 스코프를 전역 스코프라 한다.

전역 스코프에서 선언된 것들을 전역 변수라고 한다.

전역 스코프에 의존하는 것은 피해야 한다.

### 7.4 블록 스코프

let과 const는 식별자를 블록 스코프서에 선언한다.
블록 스코프는 그 블록의 스코프에서만 보이는 식별자를 의미한다.

### 7.5 변수 숨기기

내부 블록의 x는 외부 블록에서 정의한 x와는 이름만 같은 뿐 다른 변수이므로 외부 스코프의 x를 숨기는(가리는) 효과가 있다.

외부 스코프에 있는 같은 이름의 변수에 그늘이 진 듯 만든다는 의미에서 변수 숨김을 변수 섀도우라 부르기도 한다.

스코프의 계층적인 성격 때문에 어떤 변수가 스코프에 있는지 확인하는 스코프체인이라는 개념이 생겼다.

### 7.6 함수, 클로저, 정적 스코프

최신 자바스크립트에서는 함수가 필요한 곳에서 즉석으로 정의할 때가 많다.

함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것을 클로저라 부른다.

스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지된다.
또한 일반적으로는 접근할 수 없는 것에 접근할 수 있는 효과도 있다.

함수를 정의해 클로저를 만들면 접근할 수 없었던 것들에 접근할 방법이 생긴다.

### 7.7 즉시 호출하는 함수 표현식

함수 표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE)이란 것을 만들 수 있다.

IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다는 것이다.

IIFE는 함수이므로 무엇이든 반환할 수 있다.

### 7.8 함수 스코프와 호이스팅

let으로 변수를 선언하면, 그 변수는 선언하기 전에는 존재하지 않는다.
var로 선언한 변수는 현재 스코프 안이라면 어디서든 사용할 수 있으며, 심지어 선언하기도 전에 사용할 수 있다.
아직 선언되지 않은 변수는 에러를 일으키지만, 존재하되 값이 undefined인 변수는 에러를 일으키지 않는다.

var로 선언한 변수는 끌어올린다는 뜻의 호이스팅이라는 메커니즘을 따른다.
자바스크립트 함수나 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올린다.

같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없으며, let으로 가능했던 변수 숨김도 불가능하다.

### 7.9 함수 호이스팅

var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려진다.

변수에 할당한 함수 표현식은 끌어올려지지 않는다.

### 7.10 사각지대

사각지대란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현이다.
스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드이다.

### 7.11 스트릭트 모드

스트릭트 모드에서는 암시적 전역 변수를 허용하지 않는다.
