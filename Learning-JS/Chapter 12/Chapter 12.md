# Chapter 12. 이터레이터와 제너레이터

이터레이터는 '지금 어디 있는지' 파악할 수 있도록 돕는다는 면에서 일종의 책갈피와 비슷한 개념이다.
배열은 이터러블 객체의 좋은 예이다.
책에 여러 페이지가 있는 것처럼 배열에는 여러 요소가 들어 있으므로, 책에 책갈피를 끼울 수 있듯 배열에는 이터레이터를 사용할 수 있다.

배열에 values 메서드를 써서 이터레이터를 만들 수 있다.

next에서 책의 마지막 페이지를 반환했다고 해서 끝이 난 것은 아니다.
더 진행할 것이 없으면 value는 undefined가 되지만, next는 계속 호출할 수 있다.

이터레이터는 모두 독립적이다.
즉, 새 이터레이터를 만들 때마다 처음에서 시작한다.
그리고 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용할 수도 있다.

### 12.1 이터레이션 프로토콜

이터레이션 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있다.

이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.interator가 있고 이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done 프로퍼티가 있는 객체를 반환하는 next 메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체라는 뜻이다.

### 12.2 제너레이터

제너레이터란 이터레이터를 사용해 자신의 실행을 제어하는 함수이다.

제너리이터는 두 가지 새로운 개념이 있다.
하나는 함수의 실행을 개별적 단계로 나눔으로써 함수의 실행을 제어한다는 것이다.
다른 하나는 실행 중인 함수와 통신한다는 것이다.

제너레이터와 일반적인 함수의 차이

- 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있다.
- 제너레이터는 호출한 즉시 실행되지는 않는다. 대신 이터레이터를 반환하고, 이터레이터의 next 메서드를 호출함에 따라 실행된다.

제너레이터를 만들 때는 function 키워드 뒤에 애스터리스트(\*)를 붙인다.
제너레이터는 return 외에 yield 키워드를 쓸 수 있다.

#### 12.2.1 yield 표현식과 양방향 통신

제너레이터와 호출자 사이에서 양방향 통신이 가능하다.
통신은 yield 표현식을 통해 이뤄진다.
표현식은 값으로 평가되고 yield는 표현식이므로 반드시 어떤 값으로 평가된다.
yield 표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수이다.

호출자가 제너레이터에 정보를 전달하므로, 제너레이터는 그 정보에 따라 자신의 동작 방식 자체를 바꿀 수 있다.

제너레이터는 화살표 표기법으로 만들 수 없으며 반드시 function\*을 써야 한다.

#### 12.2.2 제너레이터와 return

yield 문은, 설령 제너레이터의 마지막 문이더라도 제너레이터를 끝내지 않는다.
제너레이에서 return 문을 사용하면 그 위치와 관계없이 done은 true가 되고, value 프로퍼티는 return이 반환하는 값이 된다.

제너레이터를 사용할 때는 보통 done이 true이면 value 프로퍼티에 주의를 기울이지 않는다.

제너레이터에서 중요한 값을 return으로 반환하려 하지 마라.
제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야 하고, return은 제너레이터를 중간에 종료하는 목적으로만 사용해야 한다.
