# React-16. 리덕스 라이브러리 이해하기

리덕스는 가장 많이 사용하는 리액트 상태 라이브러리
리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜서 더욱 효율적으로 관리 가능
또한, 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 손쉽게 상태 값을 전달하거나 업데이트 가능

리덕스 라이브러리는 전역 상태를 관리할 때 굉장히 효과적임
프로젝트의 규모가 클 경우에는 리덕스를 사용하는 편이 좋음
코드의 유지 보수성도 높여 주고 작업 효율도 극대화해 줌
추가로 아주 편리한 개발자 도구도 지원하며, 미들웨어라는 기능을 제공하여 비동기 작업을 훨씬 효율적으로 관리할 수 있게 해주기도 함

## 1 개념 미리 정리하기

1. 액션
   상태에 어떠한 변화가 필요하면 액션이라는 것이 발생함
   이는 하나의 객체로 표현됨

ex)
{
type: 'TOGGLE_VALUE'
}

액션 객체는 type 필드를 반드시 가지고 있어야 함
이 값을 액션의 이름이라고 생각하면 됨
그 외의 값들은 상태 업데이트를 할 때 참고해야 할 값이며, 작성자 마음대로 넣을 수 있음

ex)
{
type: 'ADD_TODO',
data: {
id: 1,
text: '리덕스 배우기'
}
}

{
type: 'CHANGE_INPUT',
text: '안녕하세요'
}

2. 액션 생성 함수
   액션 생성 함수는 액션 객체를 만들어 주는 함수

ex) function addTodo(data) {
return {
type: 'ADD_TODO',
data
};
}

// 화살표 함수로도 만들 수 있음

const chargeInput = text => ({
type: 'CHANGE_INPUT',
text
});

어떤 변화를 일으켜야 할 때마다 액션 객체를 만들어야 하는데 매번 액션 객체를 직접 작성하기 번거로울 수 있고, 만드는 과정에서 실수로 정보를 놓칠 수도 있음
이러한 일을 방지하기 위해 이를 함수로 만들어서 관리함

3. 리듀서
   리듀서는 변화를 일으키는 함수
   액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아 옴
   그리고 두 값을 참고하여 새로운 상태를 만들어서 반환

ex)
const initialState = {
counter: 1
};
function reducer(state = initialState, action) {
switch (action.type){
case INCREMENT:
return {
counter: state.counter + 1
};
default:
return state;0
}
}

4. 스토어
   프로젝트에 리덕스를 적용하기 위해 스토어를 만듦
   한 개의 프로젝트는 단 하나의 스토어만 가질 수 있음
   스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며, 그 외에도 몇 가지 중요한 내장 함수를 가짐

5. 디스패치
   스토어의 내장 함수 중 하나
   subcribe 함수 안에 리스너 함수를 파라미터로 넣어서 호출해 주면, 이 리스너 함수가 액션이 디스패치되어 상태가 업데이트될 때마다 호출됨
   이 함수가 호출되면 스토어는 리듀서 함수를 실행시켜서 새로운 상태를 만듦

6. 구독
   구독도 스토어의 내장 함수 중 하나
   subcribe 함수 안에 리스너 함수를 파라미터로 넣어서 호출해 주면, 이 리스너 함수가 액션이 디스패치되어 상태가 업데이트될 때마다 호출됨

ex)
const listener = () => {
console.log('상태가 업데이트됨');
}
const unsubscribe = store.subscribe(listener);

unsubscribe(); // 추후 구독을 비활성화할 때 함수를 호출

## 2. 리액트 없이 쓰는 리덕스

리덕스는 리액트에 종속되는 라이브러리가 아님
그래서 다른 라이브러리나 바닐라 자바스크립트와도 함께 사용 가능

프로젝트의 상태에 변화를 일으키는 것을 액션이라 함
액션 이름은 문자열 형태로, 주로 대문자로 작성하며 액션 이름은 고유해야 함
이름이 중복되면 의도하지 않은 결과 발생 가능

액션 객체는 type 값을 반드시 갖고 있어야 하며, 그 외에 추후 상태를 업데이트할 때 참고하고 싶은 값은 개발자 마음대로

초깃값의 형태는 자유

리듀서는 변화를 일으키는 함수
함수의 파라미터로는 state와 action 값을 받아 옴

리듀서에서는 상태의 불변성을 유지하면서 데이터에 변화를 일으켜 주어야 함
이 작업을 할 때 spread 연산자(...)를 사용하면 편리
단, 객체의 구조가 복잡하면 불변성 관리와 업데이트 등이 굉장히 번거롭고 코드의 가독성도 나빠지기 때문에 리덕스의 상태는 최대한 깊지 않은 구조로 진행하는 것이 좋음

객체의 구조가 복잡해지거나 배열도 함께 다루는 경우 immer 라이브러리를 사용하면 좀 더 쉽게 리듀서 작성 가능

스토어를 만들 때는 createStore 함수를 사용함
이 함수를 사용하려면 코드 상단에 import 구문을 넣어 리덕스에서 해당 함수를 불러와야 하고, 함수의 파라미터에는 리듀서 함수를 넣어 주어야 함

render은 상태가 업데이트될 때마다 호출되며, 리액트의 render 함수와는 다르게 이미 html을 사용하여 만들어진 UI의 속성을 상태에 따라 변경

이제 스토어의 상태가 바뀔 때마다 방금 만든 render 함수가 호출되도록 해 줄 것임
이 작업은 스토어의 내장 함수 subscribe를 사용하여 수행할 수 있음

subscribe 함수의 파라미터로는 함수 형태의 값 전달
이 함수는 추후 액션이 발생하여 상태가 업데이트될 때마다 호출됨

컴포넌트에서 리덕스 상태를 조회하는 과정에서 react-redux라는 라이브러리가 이 작업 대체 가능

액션을 발생시키는 것을 디스패치라고 함
디스패치를 할 때는 스토어의 내장 함수 dispatch를 사용
파라미터는 액션 객체 전달

## 3. 리덕스의 세 가지 규칙

1. 단일 스토어

하나의 애플리케이션 안에는 하나의 스토어가 들어 있음
여러 개의 스토어를 사용하는 것이 불가능하지는 않음
특정 업데이트가 너무 빈번하게 일어나거나 애플리케이션의 특정 부분을 완전히 분리시킬 때 여러 개의 스토어를 만들 수도 있지만, 상태 관리가 복잡해질 수 있음

2. 읽기 전용 상태

리덕스 상태는 읽기 전용
상태를 업데이트할 때 기존의 객체는 건드리지 않고 새로운 객체를 생성해야 함
이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 얕은 비교 검사를 하기 때문
객체의 변화를 감지할 때 객체의 깊숙한 안쪽까지 비교하는 것이 아니라 겉핥기 식으로 비교하여 좋은 성능 유지 가능

3. 리듀서는 순수한 함수

변화를 일으키는 리듀서 함수는 다음 조건 만족

- 리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받음
- 파라미터 외의 값에는 의존하면 안 됨
- 이전 상태는 절대로 건드리지 않고, 변화를 준 새로운 상태 객체를 만들어서 반환
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환

리듀서 함수 내부에서 랜덤 값을 만들거나, Date 함수를 사용하여 현재 시간을 가져오거나, 네트워크 요청을 한다면, 파라미터가 같아도 다른 결과 초래 가능
이러한 작업은 리듀서 함수 바깥에서 처리

주로 비동기 작업은 미들웨어를 통해 관리

## 4. 정리

리덕스 코드 작성 흐름

1. 액션 타입, 액션 생성 함수 작성
2. 리듀서 작성, 스토어 생성
