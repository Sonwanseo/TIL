# 15. 고차 컴포넌트

고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다.  
고차 컴포넌트는 React API의 일부가 아니며, 리액트의 구성적 특성에서 나오는 패턴이다.

구체적으로, 고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수다.

컴포넌트는 props를 UI로 변환하는 반면에, 고차 컴포넌트는 컴포넌트를 새로운 컴포넌트로 변환한다.

### 횡단 관심사에 고차 컴포넌트 사용하기

이전에는 횡단 관심사 문제를 해결하기 위해 mixin 사용을 권장했다.  
하지만 mixin을 사용하는 것은 더 많은 문제를 일으킬 수 있다.

컴포넌트는 React에서 코드 재사용의 기본 단위이다.  
그러나 어떤 패턴은 기존 컴포넌트에 잘 적용되지 않을 수 있다.

고차 컴포넌트는 입력된 컴포넌트를 수정하지 않으며 상속을 사용하여 동작을 복사하지도 않는다.  
오히려 고차 컴포넌트는 원본 컴포넌트를 컨테이너 컴포넌트로 포장하여 조합한다.  
고차 컴포넌트는 사이드 이펙트가 전혀 없는 순수 함수이다.

### 원본 컴포넌트를 변경하지 마세요. 조합하세요.

고차 컴포넌트 내부에서 컴포넌트의 프로토타입을 수정하지 않도록 한다.

고차 컴포넌트 내부에서 컴포넌트의 프로토타입을 수정하면 몇 가지 문제가 발생할 수 있다.  
그 중 하나는 입력된 컴포넌트를 확장된 컴포넌트와 별도로 재사용할 수 없다는 것이다.  
더 중요한 것은, componentDidUpdate를 변형하는 EnhancedComponent에 또 다른 HOC를 적용하면 첫 번째 HOC의 기능은 무시된다.  
이 HOC는 생명주기 메서드가 없는 함수 컴포넌트에서도 작동하지 않는다.

변경된 HOC는 누출된 추상화이다.  
Consumer는 다른 HOC와의 충돌을 피하기 위하여 어떻게 구현되어있는지 반드시 알아야 한다.

HOC는 변경 대신에 입력 컴포넌트를 컨테이너 구성요소로 감싸서 조합을 사용해야 한다.

고차 컴포넌트와 컨테이너 컴포넌트라 불리는 패턴이 유사하다고 느낄 수 있다.  
컨테이너 컴포넌트는 high-level과 low-level 관심사를 분리하는 전략 중 하나이다.  
컨테이너는 구독 및 state 같은 것을 관리하고 UI 렌더링 같은 것을 처리하는 컴포넌트에 props를 전달한다.  
고차 컴포넌트는 컨테이너를 그 구현체 중 일부에 사용하고 있다.  
고차 컴포넌트 매개변수화된 컨테이너 컴포넌트 정의로 생각할 수 있다.

### 컨벤션: 래핑된 컴포넌트를 통해 관련없는 Props 전달하기

고차 컴포넌트는 컴포넌트에 기능을 추가한다.  
고차 컴포넌트는 정의를 과감하게 변경해서는 안된다.  
고차 컴포넌트에서 반환된 컴포넌트는 래핑된 컴포넌트와 비슷한 인터페이스가 있어야 한다.

고차 컴포넌트는 특정 관심사와 관련이 없는 props를 활용해야 한다.  
대부분의 고차 컴포넌트에는 렌더링 메서드가 포함되어 있다.

이 컨벤션은 고차 컴포넌트의 유연성과 재사용성을 보장하는 데 도움된다.

### 컨벤션: 조합 가능성 끌어올리기

고차 컴포넌트는 여러 가지 방법으로 작성할 수 있다.  
때때로 단일 인수로 래핑된 컴포넌트만 받을 때도 있다.

일반적으로 고차 컴포넌트는 추가 인수를 허용한다.

### 컨벤션: 간단한 디버깅을 위한 디스플레이 네임 작성 방법

다른 구성 요소와 마찬가지로 HOC로 만든 컨테이너 구성 요소도 React Developer Tools에 표시된다.  
디버깅을 쉽게 하려면 HOC의 결과임을 알리는 디스플레이 네임을 작성한다.

가장 일반적인 방법은 HOC의 이름으로 내부 컴포넌트명을 감싸는 것이다.

### 주의사항

#### render 메서드 안에서 고차 컴포넌트를 사용하지 마세요

재조정으로 알려진 React의 비교 알고리즘은 컴포넌트의 개별성을 가지로 기존 서브 트리를 업데이트 해야 하는지 아니면 버리고 새로운 노드를 마운트해야 할 지 결정한다.  
render에서 반환된 컴포넌트가 이전에 렌더링 된 컴포넌트와 동일하다면 React가 새로운 서브 트리와 비교하여 재귀적으로 서브트리를 업데이트한다.  
동일하지 않다면 이전 서브트리는 완전히 마운트 해제된다.

render 메서드 안에서 고차 컴포넌트를 사용하면 성능상의 문제뿐만 아니라 컴포넌트가 다시 마운트되면서 컴포넌트의 state와 컴포넌트의 하위 항목들이 손실된다.

대신에 컴포넌트의 정의 바깥에 HOC를 적용하여 컴포넌트가 한 번만 생성되도록 한다.  
그러면 해당 컴포넌트는 여러번 렌더링이 되더라도 일관성을 유지한다.

HOC를 동적으로 적용해야 할 경우에는 컴포넌트의 생명주기 메서드 또는 생성자 내에서 작성할 수 있다.

#### 정적 메서드는 반드시 따로 복사하세요

리액트 컴포넌트에 정적 메서드를 정의하는 것이 유용할 때도 있다.

컴포넌트에 HOC를 적용하면, 기존 컴포넌트는 컨테이너의 컴포넌트로 감싸진다.  
즉, 새 컴포넌트는 기존 컴포넌트의 정적 메서드를 가지고 있지 않다.

이 문제를 해결하려면 메서드를 반환하기 전에 컨테이너에 복사한다.

하지만 이 경우 복사해야 할 메서드를 정확히 알아야 할 필요가 있다.  
hoist-non-react-statics를 사용하여 모든 non-React 정적 메서드를 자동으로 복사할 수 있다.

또 다른 해결 방법은 정적 메서드를 컴포넌트와 별도로 내보내는 것이다.

#### ref는 전달되지 않는다

고차 컴포넌트는 모든 props를 래핑된 컴포넌트에 전달하는 것이 원칙이지만, refs에서는 작동하지 않는다.  
이는 리액트에서 ref가 실제 prop이 아닌 key처럼 특별하게 취급되기 때문이다.  
컴포넌트가 HOC의 결과인 엘리먼트에 ref를 추가하는 경우, ref는 래핑된 컴포넌트가 아닌 가장 바깥쪽 컨테이너 컴포넌트의 인스턴스를 나타낸다.

이 문제의 해결 방법은 React.forwardRef API를 사용하는 것이다.