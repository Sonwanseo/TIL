# React 11-componentOptimization 컴포넌트 성능 최적화

## 1. 많은 데이터 렌더링하기

useState에 파라미터를 함수 형태로 넣어 주면 컴포넌트가 처음 렌더링될 때만 함수 실행

## 2. 크롬 개발자 도구를 통한 성능 모니터링

성능을 분석해야 할 때 정확히 몇 초가 걸리는지 확인해야 하는데, 크롬 개발자 도구의 Performance 탭을 사용하여 측정 가능

## 3. 느려지는 원인 분석

컴포넌트는 다음과 같은 상황에서 리렌더링이 발생함

1. 자신이 전달받은 props가 변경될 때
2. 자신의 state가 바뀔 때
3. 부모 컴포넌트가 리렌더링될 때
4. forceUpdate 함수가 실행될 때

이럴 때는 컴포넌트 리렌더링 성능을 최적화해 주는 작업을 해 주어야 함
즉, 리렌디링이 불필요할 때는 리렌더링을 방지해 주어야 함

## 4. React.memo를 사용하여 컴포넌트 성능 최적화

컴포넌트의 리렌더링을 방지할 때는 shouldComponentUpdate라는 라이프사이클 사용
하지만, 함수형 컴포넌트에서는 라이프사이클 메소드 사용 불가
그 대신 React.memo 함수 사용
컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능 최적화 가능

## 5. onToggle, onRemove 함수가 바뀌지 않게 하기

현재 프로젝트에서는 todos 배열이 업데이트되면 onRemove와 onToggle 함수도 새롭게 바뀜
onRemove와 onToggle 함수는 배열 상태를 업데이트 하는 과정에서 최신 상태의 todos를 참조하기 때문에 todos 배열이 바뀔 때마다 함수가 새로 생성됨

해결 방법

1. useState의 함수형 업데이트 기능 사용
2. useReducer 사용

useState
기존에 setTodos 함수를 사용할 때는 새로운 상태를 파라미터로 전달
setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수 전달 가능
이를 함수형 업데이트라 칭함

useReducer
useReducer를 사용할 때는 원래 두 번째 파라미터에 초기 상태를 넣어 주어야 함
그 대신, 두 번째 파라미터에 undefined를 넣고, 세 번째 파라미터에 초기 상태를 만들어 주는 함수를 전달하면
컴포넌트가 맨 처음 렌더링될 때만 함수 호출

useReducer를 사용하는 방법은 기존 코드를 많이 고쳐야 한다는 단점
상태를 업데이트하는 로직을 모아서 컴포넌트 바깥에 둘 수 있다는 장점

## 6. 불변성의 중요성

기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 '불변성을 지킨다'라고 함
전개 연산자(... 문법)를 사용하여 객체나 배열 내부의 값을 복사할 때는 얕은 복사를 하게 됨
즉, 내부의 값이 완전히 새로 복사되는 것이 아니라 가장 바깥쪽에 있는 값만 복사
따라서 내부의 값이 객체 혹은 배열이라면 내부의 값 또한 따로 복사해 주어야 함

배열 혹은 객체의 구조가 정말 복잡해진다면 이렇게 불변성을 유지하면서 업데이트하는 것도 까다로워짐
이렇게 복잡한 상황일 경우 immer라는 라이브러리의 도움을 받으면 정말 편하게 작업 가능

## 7. TodoList 컴포넌트 최적화

리스트에 관련된 컴포넌트를 최적화할 때는 리스트 내부에서 사용하는 컴포넌트도 최적화해야 하고, 리스트로 사용되는 컴포넌트 자체도 최적화해 주는 것이 좋음
리스트 관련 컴포넌트를 작성할 때는 리스트 아이템과 리스트, 이 두 가지 컴포넌트를 최적화해 주는 것 기억
그러나 내부 데이터가 100개를 넘지 않거나 업데이트가 자주 발생하지 않는다면, 이런 최적화 작업 반드시 할 필요 X

## 8. react-virtualized를 사용한 렌더링 최적화

컴포넌트가 맨 처음 렌더링될 때 2,500개 컴포넌트 중 2,491개 컴포넌트는 스크롤하기 전에는 보이지 않음에도 불구하고 렌더링 -> 비효율
그리고 나중에 todos 배열에 변동이 생길 때도 TodoList 컴포넌트 내부의 map 함수에서 배열의 처음부터 끝까지 컴포넌트로 변환해 주는데, 이 중 2,491개는 보이지 않으므로 시스템 지원 낭비

react-virtualized를 사용하면 리스트 컴포넌트에서 스크롤되기 전에 보이지 않는 컴포넌트는 렌더링하지 않고 크기만 차지하게끔 할 수 있음
만약 스크롤되면 해당 스크롤 위치에서 보여 주어야 할 컴포넌트를 자연스럽게 렌더링시킴

List 컴포넌트를 사용할 때는 해당 리스트의 전체 크기와 각 항목의 높이, 각 항목을 렌더링할 때 사용해야 하는 함수, 그리고 배열을 props로 전달
그러면 이 컴포넌트가 전달받은 props를 사용하여 자동으로 최적화

## 9. 정리

리액트 컴포넌트의 렌더링은 기본적으로 빠르기 때문에 컴포넌트를 개발할 때 최적화 작업에 대해 큰 스트레스를 받거나 모든 컴포넌트에 일일이 React.memo를 작성할 필요 X
단, 리스트와 관련된 컴포넌트를 만들 때 보여 줄 항목이 100개 이상이고 업데이트가 자주 발생한다면, 이 장에서 학습한 방식을 사용하여 꼭 최적화 하기 바람
